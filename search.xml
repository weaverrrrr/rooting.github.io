<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>社畜的生活备忘录</title>
      <link href="/2019/11/02/life-experience/"/>
      <url>/2019/11/02/life-experience/</url>
      
        <content type="html"><![CDATA[<p>毕业到现在也只有一年多，但我的人生阅历可以算是比较丰富了。刚毕业却碰上裁员潮在程序员节当天通知被裁，然后一手操办买房装修，好不容易又进了喜欢的公司待了一年不到就被抄了，还经历了派出所一日游，趁着赋闲在家装修收尾却又发现装修公司倒闭……不过这么多经历也算是种财富，所以写个备忘录记录下~<br><a id="more"></a></p><h2 id="安家篇"><a href="#安家篇" class="headerlink" title="安家篇"></a>安家篇</h2><h3 id="应届生本科落户公司"><a href="#应届生本科落户公司" class="headerlink" title="应届生本科落户公司"></a>应届生本科落户公司</h3><blockquote><p>备注：仅适用于户口在老家与51信用卡集体户口，不同公司不同时间可能不同。</p></blockquote><p><strong>Step1：档案调到我司</strong><br>学校将档案寄到人才市场后在<a href="http://rsdl.zjrc.com/personlogin.do" target="_blank" rel="noopener">浙江人才人事代理网站</a>查询，如有记录（很慢）就能进行Step2</p><ul><li>我们学校（浙工大）是把档案直送到人才市场的，7月15日左右送出，8月6日左右能查到</li><li>如果是外省邮寄，差不多10个工作日就能录入了</li><li>有问题或者长时间都没到可以打 0571-88392911 问</li></ul><p><strong>Step2：提交材料去小营派出所办理《准予迁入证明》</strong></p><ol><li>毕业证、身份证、劳动合同的原件及复印件</li><li>户口本原件与复印件，或户籍证明</li><li>杭州市社会保险参保证明原件（彩打）：<ul><li>支付宝搜索“杭州人力社保” =&gt; 办社保，选择参保类型“个人专用”</li><li>需要一个月以上记录且显示到账才行，到账一般会有一两个月延迟，比如7月的社保大概8月底到账。</li></ul></li><li>《无房证明》（彩打）：<a href="http://hz.zjzwfw.gov.cn/" target="_blank" rel="noopener">浙江政务服务网</a> =&gt; (热点服务)个人住房信息查询</li><li>落户协议、同意落户证明、人事代理协议复印件：等档案到人才市场后找外服取</li></ol><table><thead><tr><th>单位</th><th>社会保险管理服务局</th><th>小营派出所</th></tr></thead><tbody><tr><td>地址</td><td>杭州市上城区清吟街123号社保大楼</td><td>杭州市上城区翰林街107号</td></tr><tr><td>电话</td><td>12333</td><td>0571-87800209</td></tr><tr><td>服务时间</td><td>周一至周五 9:00-17:00</td><td>周一到周六 8:30-12:00 14:30-17:30</td></tr><tr><td>备注</td><td></td><td>周六办理落户相关业务限号，上午下午各限30位。</td></tr></tbody></table><ul><li>【跑两趟】交完材料要再过几天才能拿到《准予迁入证明》，拿到就能进行Step3或者Step4了</li><li>如果户籍是浙江省内户口的话这不就不用Step3了，可以直接Step4</li></ul><p><strong>Step3：回户籍所在地派出所出具《户口迁移证》</strong><br>本人持《准予迁入证明》、户口本原件，也可让在同一户口本上的人代办。<br>拿到《户口迁移证》就能进行Step4了。</p><p><strong>Step4：小营派出所落户</strong><br>持《户口迁移证》（需要的话及户口簿原件办理落户。最后拍个身份证（穿深色上衣）就over啦~</p><h3 id="看房买房"><a href="#看房买房" class="headerlink" title="看房买房"></a>看房买房</h3><p><strong>看房</strong></p><ul><li>可以的话还是选择一手房，摇号可以微信搜下“摇号管家”</li><li>如果要买二手房，一定要多去些地方，多找几个中介看房，等看得多了再决定要哪个小区</li><li>如果要考虑孩子教育问题的话最好还是西湖区，学区不会太差，将来要换房也好脱手</li><li>拆迁房要谨慎考虑，很多房子政府拆不起。如果非要拆迁房，大马路边的容易被拆</li></ul><p><strong>定房</strong></p><blockquote><p>备注：我买的二手房，所以以下建议仅适合二手房</p></blockquote><ul><li>最好是找小中介定房子，扯一扯能省下好多万中介费，三百万以下的房子两万就能搞定</li><li>全款还是贷款就看自己了，预算充足的话推荐贷款多买几套，房价跌不了</li><li>合同好好看，一定要讲清楚什么时候交房及延期赔偿，尤其是出租屋，比较麻烦</li><li>签合同过户什么的中介都会帮忙安排，过户的时候记得打扮打扮，要和前房东合影存档</li><li>最好再买车位，车位费也一直在涨</li></ul><h3 id="装修"><a href="#装修" class="headerlink" title="装修"></a>装修</h3><blockquote><p>备注：我是找的装修公司，且原先为自如出租房</p></blockquote><h4 id="找施工队"><a href="#找施工队" class="headerlink" title="找施工队"></a><strong>找施工队</strong></h4><ul><li>最好是找认识的施工队，比较便宜，还没听说过非常靠谱的装修公司。如果要定装修公司的话早点挑，蹲着他们搞活动（比如双旦）</li><li>最好先去看下装修公司的样板房，有些装修公司的风格都比较老气，顺便看下公司大不大，靠不靠谱，装到一半跑路了就麻烦了</li><li>签合同的时候要白纸黑字写好日后怎么算延期赔偿、是否包含节假日及周末、保洁是否为公司承担，管理费好砍价，并且多要点赠品，比如送个全屋美缝呀优惠券啥啥的</li><li>尾款一定一定一定要装修验收完、质保有效、公司没倒闭、延期赔偿扯清楚了，再去付，装修基本上都会延期的</li><li>多问问爸妈，爸妈经验丰富还会砍价</li></ul><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a><strong>设计</strong></h4><ul><li>可以去酷家乐看看自己喜欢的风格给设计师做参考，可以省去很多改稿时间</li><li>最好设计阶段就把冰箱、洗衣机等大件电器定下来，不然就像我家那样发现用小冰箱都会撞着门呜呜呜</li><li>色调多用白、灰、原木就是北欧简约了，不会很难看</li><li>插座多留点，特别是卫生间和厨房，保不准以后要多装些智能电器</li><li>对照下楼上楼下的户型结构，以免日后由于漏水、排污管等问题起冲突</li><li>早点加业主群，平时多窥屏看看小区房子有什么问题，装修阶段少讲话当个小透明，不然装修吵到邻居了会在群里被艾特骂的</li></ul><h4 id="施工阶段"><a href="#施工阶段" class="headerlink" title="施工阶段"></a><strong>施工阶段</strong></h4><ul><li>大致流程：砌墙 → 水电 → 泥木 → 墙饰面处理 → 成品、灯具、五金安装，一般是60个工作日完工，我们家是3月20日开工，9月12日才完工验收，延期了一个多月。</li><li>拆旧的时候一定要保护好窗户轨道和地漏，我家地漏全堵了呜呜呜，多花了好多钱修</li><li>水要走顶，多检查卫生间、露台的防水、堵漏情况</li><li>多在下完暴雨的时候看看哪里有堵漏，比如露台墙、各房窗户沿</li><li>建议装个松下新风，城市空气质量堪忧。地暖看闲钱多不多了，中央空调的话个人建议是150平以下没必要，平方不大的反而耗电</li><li>瓷砖推荐做个美缝，不然时间久了会很丑</li><li>要和物业打好关系，因为我们小区入住率比较高，装修时间很严格，经常要去找物业，还花了很多冤枉钱</li><li>露台问题，先去问物业能不能封再动工，或者等装修完了再去封，阳光房还算违建的</li></ul><h4 id="置办家电"><a href="#置办家电" class="headerlink" title="置办家电"></a><strong>置办家电</strong></h4><blockquote><p>备注：以下建议适合我这种精打细算省钱的，土豪可以不看</p></blockquote><ul><li>买家具还是得品牌店买，淘宝上的看不到，容易买到次品，最好是碰着哪家家具店开业搞活动，我那时候是正巧碰上了曲美家具新门店开业打7折，质量挺不错的</li><li>买电器淘宝没问题，国庆活动力度不大别买，还是得等双十一，我就吃了亏</li><li>据说双十一电信200M一年只要六百多，我是去都市水乡分店办了69/月的，奇怪的是另一家门店说没有69的，说法还不一样，要多跑几家，碰碰运气多问问</li><li>理智消费，很多东西个人觉得没必要买或者买太好，有些东西利润太高，完全可以找小店以低价买到同等质量的，比如窗帘（我可以推荐朋友家的店~）</li><li>必备神器：激光测距仪、无痕钉、美纹纸、折叠梯、小榔头、小推车</li></ul><h4 id="花费清单，仅供参考"><a href="#花费清单，仅供参考" class="headerlink" title="花费清单，仅供参考"></a><strong>花费清单，仅供参考</strong></h4><blockquote><p>约 364394</p></blockquote><ul><li>装修公司总费用 - 208000</li><li>物业装修押金（1000次年拿回）、代办(400) - 1400</li><li>拆旧 - 7612 </li><li>松下新风 - 13000</li><li>包阳台 - 12856</li><li>被举报违建拆阳光房费用 - 200 </li><li>通下水道7次(960)、门窗修补(300)、拆旧误拆水龙头(300) - 1560 </li><li>泥沙、木料、油漆、水泥、垃圾搬运费 - 4000</li><li>木工增加项 - 1500</li><li>方太油烟机灶具、止回阀、天然气开通 - 5029</li><li>松下暖风机、林内热水器、安装费 - 7625</li><li>灯具 * 7、安装 - 2197</li><li>曲美，包括2床具1客厅三件套4桌椅1按摩沙发2背景等木质家具 - 60600</li><li>冰箱洗衣机空调 - 13992</li><li>淘宝家具、装饰及日用品 - 10497</li><li>小电器 - 6526</li><li>阳台洗衣池 - 1800</li><li>窗帘 - 2500</li><li>又包露台 - 3500</li></ul><h2 id="工作篇"><a href="#工作篇" class="headerlink" title="工作篇"></a>工作篇</h2><h3 id="万一不幸被裁员了"><a href="#万一不幸被裁员了" class="headerlink" title="万一不幸被裁员了"></a>万一不幸被裁员了</h3><blockquote><p>互联网公司裁员还是比较常见的，脉脉上经常看到裁员消息，比较常见的原因：公司赚不着钱、项目被砍、公司上市（上市前为了报表好看会扩招）、公司被收购、以271考核为由结构优化。所以还是得有危机意识，要不断提升自己水平，不然保不准就被裁了。</p></blockquote><ol><li>不要立马签离职协议，先把该问的都问清楚，尽量晚点签。</li><li>如果是大面积裁员的，先去找到组织，找微信群大家好交流互助。</li><li>首先要搞清楚赔偿几个月及赔偿规则，也去问下其他人都赔了几个月。<ul><li>常听说的N+数字（比如N+1)里面的N是入职年份。</li><li>公司因为效益不好裁员，如果提前30天通知职工的话，赔N就可以了，如果没有提前30天的，就是工龄补偿加一个月工资作为代通知金，也就是N+1。我这次碰到的N+2，就是 工龄补偿 + 代通知金 + 年终奖补偿。（<a href="https://www.sohu.com/a/150454105_367376）" target="_blank" rel="noopener">https://www.sohu.com/a/150454105_367376）</a></li><li>注意，N是有上限的，比如超过16K也算16K。</li><li>工资另外算，赔偿不计税</li></ul></li><li>如果裁员时间是国庆或者春节这类长假的月份，问清楚最后一个月的工资是按月算还是按日算。<ul><li>十月份工作日少，无良公司会钻漏洞省不少钱。</li><li>按天算的话，工资要 / 21.5 * 这个月的实际工作日，国庆节假期算没有工资。</li><li>尽量不要在有假期的月份请事假。如10月31号走，是满月，就不能按天计算，否则可以少发我们6.5天工资。</li></ul></li><li>最好签主动离职，不能为了失业金而签被动离职的协议，否则档案里不好看，可能会对下一份工作有影响。</li><li>公积金断了没事（除非需要公积金贷款），社保要多争取下，断了会对买房、医保有影响，公司不让步的话可以自己淘宝代缴，离职后记得在月初把社保交上。</li><li>如果对电脑有感情了可以去问下能不能买，不过得问清楚会不会拆你硬盘，要拆的话那就很不划算了。</li><li>如果是公司的集体户口的话，要去找外服，一般是两个月内迁出，如果两个月内没找到迁出地的话可以去人才中心临时挂靠下。一定要问清楚这个哦，可能会产生挂靠费。</li><li>如果不明白的可以打律师咨询电话，该提仲裁还是要大胆的去提。</li></ol><h3 id="如果不幸公司被抄了"><a href="#如果不幸公司被抄了" class="headerlink" title="如果不幸公司被抄了"></a>如果不幸公司被抄了</h3><blockquote><p>魔蝎被抄圈内应该是人尽皆知了，事发突然，作为第一家被抄的公司，也是jc叔叔眼中的典型了。枪打出头鸟，那时我才知道，原来魔蝎在业内名气是这么响的，我居然也是重大案件里的犯罪嫌疑人，也会被刑事问询并且扣押24小时，真的像做梦一样。</p></blockquote><ul><li>当时是两百多位便衣JC叔叔涌进公司，迅速控制住了我们公司一百二十余人，没收手机电脑，就这么陷入了全体失联状态。所有人被分批送去不同派出所，我们那批是8人，男女分开关押。为了安全，是需要取下鞋带、皮筋、眼镜等物品的，外套别脱，里面很冷。环境也是非常压抑的，密闭房间，无法知道时间，时刻被三位以上的人员盯着，不允许讲话及大幅度动作</li><li>拘传不得超过24小时，所以如果没犯法也不用怕，最多不玩手机24小时。审讯室里积极配合就好，JC叔叔也不是穷凶极恶的人，也不要有心理负担，没犯法的不会留案底（期间有个叔叔看我太瘦了问我有没有吸毒，看完守护解放西后觉得叔叔可能是认真的Ծ‸Ծ）</li><li>被扣押后是不允许与外界联系的，但是如果家门钥匙只有一把且在你包里的话是可以求情联系下的。虽然是失联了，但只要家属一去公司看下就知道情况了，可以一个个打电话给各个派出所问人在哪里，如果找到了可以饭点送（仅限）面包进去。所以家属把人接到后好好带着吃几顿大鱼大肉安抚安抚</li><li>如果24小时还没放人，就要等48小时或者取保候审，然后准备好请律师，可能会有点麻烦了</li><li>出去以后不要理会那些想要采访的人，不信谣不传谣，不要向别人透露本案信息，一切以官方消息为准</li><li>公司被抄基本上就凉了，就准备找工作吧。公司的U盾、资产是被封着的，所以工资、五险一金都是结案后才能补发，而调查时间基本都是要好几个月。接着员工成立工会，可以与相关部门争取离职证明</li><li>处理五险一金很重要，连续3个月才构成断缴，最好两个月后去电话咨询下办理停保的时间及统一办理停保的方案。</li><li>最后，慎重选择公司，看到几家网贷公司被抄后都要求所有格员工退还所有工资，太惨了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别魔蝎</title>
      <link href="/2019/10/23/goodbyeMoxie/"/>
      <url>/2019/10/23/goodbyeMoxie/</url>
      
        <content type="html"><![CDATA[<p><strong>魔蝎科技</strong>是我入职的第二家公司，只有一百多人，看起来是小公司，但在业内是很出名的。从2019年2月初入职算起到9月初被抄也只有7个月，公司从蒸蒸日上到轰然倒塌也只是一瞬间啊。我这经历也算是十分稀有了，人生阅历又提高了一个等级。<br><a id="more"></a></p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><ul><li>2019-02-13 ：入职魔蝎，进入大前端组</li><li>2019-06-初：试用期结束，转正</li><li>2019-09-06：被带走/(ㄒoㄒ)/~~</li><li>2019-10-16：正式离职</li></ul><p>说来我和魔蝎也是非常有缘了，投简历时并不知道魔蝎，面试了才发现，老板以前也从51出来，前端主管还是工大学长，还有很多很多工大和51出来的人（面一半让我下次来，过了半小时再让我回去继续面的经历也是和51一样的哈哈）。本身对魔蝎第一印象就不错，技术型公司也比较稳，再加上这奇妙的缘分，我就直接选择了这家公司。</p><p>魔蝎主要靠技术吃饭，技术人员比例极高，也是这个原因，技术氛围是相当不错了，不光测试、产品，连运营、项管都懂些基本的开发知识，需求交流起来很是舒服。按人数来说算是一家小公司了，因为人少，所以基建没有那么完善，发布新项目、图片放CDN等都要找运维大哥（都是排着队找运维大哥，太忙了），发布也是简单粗暴得直接操作Jenkins。不过人少也有好处，不同项目总有很多熟面孔，气氛总是很融洽，找人也方便。</p><p>也同样是因为人少，魔蝎这边是大前端概念，仅有的iOS小哥、唯二的Android小哥和唯二的UI小姐姐也算前端组，大前端组除了写基本的页面和应用，也做node、RN和爬虫，还做区块链和机器学习等等，一直有尝试新技术，接手的项目类型也是挺多样的，能接触到各种领域，真的是个很好的成长环境。（更加喜欢的是工作之余的扯皮，都是一群有趣的人呀，聊起天来和相声一样）</p><p>魔蝎真的是家很温暖的公司呀，回想起9月6日那天就像做梦一样，两百多个警员冲进2楼，带走了我们120个员工，在派出所被扣押了24小时。下午两点多前一秒还赶着写代码，后一秒就被乌泱泱一大片的警员包围了，此处不得不夸一下杭州警方，迅速控制，设备齐全，据说早一个月就制定好了计划，于是全体失联，幸亏老刘警觉5点多就去公司找我。哎…</p><p><br></p><h2 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h2><h3 id="团队工作"><a href="#团队工作" class="headerlink" title="团队工作"></a>团队工作</h3><ul><li>参与前端基础建设工作，包括规范制定、base工具库及模板项目的开发</li><li>参与前端技术分享活动，为推动前端组技术出谋划策</li></ul><hr><h3 id="魔蝎官网"><a href="#魔蝎官网" class="headerlink" title="魔蝎官网"></a>魔蝎官网</h3><p>时间：2019-02-18 ~ 2019-09-06<br>技术栈：Egg + React + Webpack + Antd </p><h4 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>负责<a href="https://www.91moxie.com/" target="_blank" rel="noopener">公司官网</a>的日常内容更新及维护。</li><li>完成了react SSR的升级，优化SEO，显著提高了官网在搜索引擎内的自然排名。</li><li>新增使用了若干接口，大大减少了管理官网内容的工作量。</li></ul><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p>这算是刚进公司接手的新手级项目，展示了公司的产品、特色及动态。接手时是纯静态的，但改动较频繁，经常需要更换banner及动态内容，因此就凸显出了动态配置的重要性，增加接口后事倍功半。且小型项目适合练手，所以这也是第一个升级ssr的项目，大大优化了SEO。</p><hr><h3 id="开放平台"><a href="#开放平台" class="headerlink" title="开放平台"></a>开放平台</h3><p>时间：2019-02-19 ~ 2019-04-11<br>技术栈：React + Webpack + Antd + bizCharts</p><h4 id="工作内容-1"><a href="#工作内容-1" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>完成接手期间开放平台的日常更新维护及小功能迭代</li><li>完成3.0大版本升级，包括去除云概念、UI升级、新增若干模块、代码整体优化</li></ul><h4 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h4><p>开放平台是供客户公司的开发者使用的平台，致力于帮助客户自主管理业务，功能包括资质审核、产品接入、数据管理、测试服务、账单查询、联系人管理、消息中心等等。开放平台是对外且复杂的一个系统，所以比较重要，3.0的升级由我和另一同事一起完成，除了对模块、流程及UI进行了大调整外，对整体代码也进行了优化和规范，在提高业务处理效率的同时，提升了代码质量，规避了很多风险。</p><hr><h3 id="魔蝎SDK-H5"><a href="#魔蝎SDK-H5" class="headerlink" title="魔蝎SDK-H5"></a>魔蝎SDK-H5</h3><p>时间：2019-04-15 ~ 2019-09-06<br>技术栈：React + Webpack</p><h4 id="工作内容-2"><a href="#工作内容-2" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>4月中到8月初期间，协助修改H5相关问题。</li><li>8月初正式接手此项目，负责解决SDK H5相关bug及小功能修改。</li></ul><h4 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h4><p>moxie SDK是公司非常重要的一个项目，sdk-h5是采集用户信息的入口，此项目通过界面引导用户授权各平台来帮助获取各种可用信息。sdk-h5由于流程复杂、页面数量大且涉及到的项目成员众多，是个需要非常谨慎对待的庞大项目。所以这个项目的流程是非常规范的，也是比较磨练开发人员，每次改动都必须考虑到所有情况。这个项目经手过很多人，搞懂流程及代码也着实费了我不少精力。</p><hr><h3 id="魔链授权"><a href="#魔链授权" class="headerlink" title="魔链授权"></a>魔链授权</h3><p>时间：2019-04-27 ~ 2019-05-21<br>技术栈：React + Webpack + Antd </p><h4 id="工作内容-3"><a href="#工作内容-3" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>从零开发魔链授权项目</li><li>负责魔链授权项目的维护及迭代</li></ul><h4 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h4><p>魔链授权项目的目的是在SDK数据授权过程中让用户选择是否将采集结果上链，使用魔蝎的魔链产品，能让授权采集过程更加高效与安全，也是为C端产品线提前铺路。此项目需要与魔蝎SDK-H5、开放平台及魔链进行联调，开发难度也体现在这一点上，中间还涉及到与sdk-h5的数据加解密及传递信息，也算是有点复杂的一个项目了。</p><hr><h3 id="区块链可信建模平台"><a href="#区块链可信建模平台" class="headerlink" title="区块链可信建模平台"></a>区块链可信建模平台</h3><p>时间：2019-05-13 ~ 2019-09-06<br>技术栈：Egg + React + Webpack + Antd + ECharts</p><h4 id="工作内容-4"><a href="#工作内容-4" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>与另一同事协作从零开发并完成整个系统，使用了SSR框架，我主要负责“首页”、“我的项目”、“使用教程”、“数据上传”及“模型构建”模块。</li></ul><h4 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h4><p>魔蝎可信建模平台是一项基于区块链技术作为底层数据隐私保护，方便客户提供自有数据与魔蝎大数据风险指标联合建模，并对模型进行全生命周期管理的一站式平台。平台包括数据上传、模型构建、安全训练等功能。此项目图表数量多、数据量大、参数多、关联性强，我们在图表基本功能完善的前提下，提出并完成了许多性能、交互方面的优化点。</p><hr><h3 id="设备指纹SDK-JS"><a href="#设备指纹SDK-JS" class="headerlink" title="设备指纹SDK-JS"></a>设备指纹SDK-JS</h3><p>时间：2019-07-08 ~ 2019-09-06<br>技术栈：Webpack + CryptoJS + JSEncrypt </p><h4 id="工作内容-5"><a href="#工作内容-5" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>SDK js版本：独立开发设备指纹SDK的JS版本，主要功能是收集上报web端的事件、设备硬件、浏览器、物理加速度及方向等信息。</li><li>设备指纹报告页（React/Webpack/Antd）：独立开发报告页供内部及客户查阅，内容包括iOS、Android和H5三大平台的原始数据信息及分析结果。</li></ul><h4 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h4><p>设备指纹sdk能收集硬软件多维信息，生成能有效对抗黑产的唯一设备ID，实现终端设备上的各类风险检测、行为分析，有效侦测模拟器、刷机改机、团伙作弊等欺诈行为，有效对抗网络爬虫、虚假交易等恶意行为。我负责的js版本主要是尽可能收集并上报web端的多重信息以提高SDK针对各类风险设备及环境的识别率，实时防御营销活动作弊、刷榜刷单等欺诈行为，护航客户的营销ROI增长。</p><hr><h3 id="AI引导页"><a href="#AI引导页" class="headerlink" title="AI引导页"></a>AI引导页</h3><p>时间：2019-07-24 ~ 2019-09-06<br>技术栈：React + Webpack + Antd </p><h4 id="工作内容-6"><a href="#工作内容-6" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>负责AI辅助认证APP内置H5引导页的开发</li></ul><h4 id="要点-6"><a href="#要点-6" class="headerlink" title="要点"></a>要点</h4><p>使用AI辅助认证APP只需开启无障碍功能，即可自动认证，而本项目是内嵌在APP中的H5引导页，提示用户当前AI套餐认证过程中会出现的页面，防止用户因为没有耐心而关闭退出。此项目为简单的静态页面。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>commit辅助工具</title>
      <link href="/2019/04/19/tool-commit/"/>
      <url>/2019/04/19/tool-commit/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><strong>工具推荐：</strong></p><ul><li><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">Commitizen</a>：是一个撰写合格 Commit message 的工具。</li><li><a href="https://github.com/commitizen/cz-conventional-changelog" target="_blank" rel="noopener">cz-conventional-changelog</a>：是符合AngularJS规范的Commitizen标准配置插件。</li><li><a href="https://github.com/conventional-changelog/standard-version" target="_blank" rel="noopener">standard-version</a>：根据符合规范的commit记录自动生成更改日志文件。</li><li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">commitlint</a>：检查 commit 信息是否符合规范。</li><li><a href="https://github.com/carloscuesta/gitmoji" target="_blank" rel="noopener">gitmoji</a>：私人项目可以用用这个比较俏皮有趣的插件。</li></ul><a id="more"></a><p><strong>commit格式规范：</strong></p><p>每条commit记录都由header、body、footer(标题行、详细内容、尾部标注)组成。header具有特殊格式，包括type、scope、subject(类型、修改范围、简短描述)，其中，Header 是必需的，Body 和 Footer 可以省略：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>): <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br><span class="line">// 空行</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">// 空行</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>header中的scope类型有以下几种：</strong></p><ul><li>feat: 新功能（feature）</li><li>fix: 修补bug </li><li>docs: 文档改动</li><li>style: 不影响代码运行的格式改动</li><li>refactor: 重构，不是新增功能或修补bug的代码变动</li><li>perf: 提高代码性能的代码变动</li><li>test: 新增或修改测试用例</li><li>build: 影响构建系统或外部依赖的更改（如webpack、broccoli、npm等）</li><li>ci: 对CI配置文件和脚本的变动（如travis、circle、browserstack、saucelabs等）</li><li>chore: 不涉及src或测试文件的代码变更 </li><li>revert: 代码回退</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>团队项目安装个Commitizen差不多就可以了。</li><li>如果需要生成CHANGELOG文件，再单独安装下standard-version即可。</li><li>如果想要非常非常严格的规范，可以统一安装commitlint，并配上<a href="https://github.com/conventional-changelog/commitlint/blob/master/@commitlint/config-conventional" target="_blank" rel="noopener">@commitlint/config-conventional</a>官方推荐配置。</li></ul><h3 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h3><p><strong>推荐项目级安装：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install commitizen --save-dev</span><br><span class="line">commitizen init cz-conventional-changelog --save-dev --save-exact</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><p>1、执行<code>git add .</code>后使用<code>git cz</code>替代<code>git commit</code>命令。</p><p>2、按下回车后按提示输入commit信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">? Select the type of change that you&apos;re committing:</span><br><span class="line">  docs:     Documentation only changes</span><br><span class="line"></span><br><span class="line">? What is the scope of this change (e.g. component or file name)? (press enter to skip)</span><br><span class="line">   更改范围headerScope</span><br><span class="line"></span><br><span class="line">? Write a short, imperative tense description of the change:</span><br><span class="line">   简单描述headerSubject</span><br><span class="line"></span><br><span class="line">? Provide a longer description of the change: (press enter to skip)</span><br><span class="line">   详细描述(body)</span><br><span class="line"></span><br><span class="line">? Are there any breaking changes?</span><br><span class="line">   Yes</span><br><span class="line"></span><br><span class="line">? Describe the breaking changes:</span><br><span class="line">  当前代码与上一版本不兼容，说明对变动的描述、理由和迁移方法(footer)</span><br><span class="line"></span><br><span class="line">? Does this change affect any open issues?</span><br><span class="line">   Yes</span><br><span class="line"></span><br><span class="line">? Add issue references (e.g. &quot;fix #123&quot;, &quot;re #123&quot;.):</span><br><span class="line">   fix #相关issue(footer)</span><br></pre></td></tr></table></figure><p>3、若提交失败，执行<code>git cz —retry</code>进行重试则不需要重新输入信息。</p><p>4、提交成功后，就能看到log记录格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Author: zhaoluting &lt;zhaoluting@51dojo.com&gt;</span><br><span class="line">Date:   Thu Apr 18 19:49:31 2019 +0800</span><br><span class="line"></span><br><span class="line">    docs(更改范围headerScope): 简单描述headerSubject</span><br><span class="line">    </span><br><span class="line">    详细描述(body)</span><br><span class="line">    </span><br><span class="line">    BREAKING CHANGE: 当前代码与上一版本不兼容，说明对变动的描述、理由和迁移方法(footer)</span><br><span class="line">    </span><br><span class="line">    fix #相关issue(footer)</span><br></pre></td></tr></table></figure><h3 id="standard-version"><a href="#standard-version" class="headerlink" title="standard-version"></a>standard-version</h3><ol><li>推荐全局安装：<code>npm install standard-version -g</code></li><li>项目下运行<code>standard-version</code>，会自动生成CHANGELOG.md文件、变更版本号、提交commit、打tag。并出现以下提示:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">✔ bumping version in package.json from 2.0.2 to 2.0.3</span><br><span class="line">✔ bumping version in package-lock.json from 2.0.2 to 2.0.3</span><br><span class="line">✔ outputting changes to CHANGELOG.md</span><br><span class="line">✔ committing package-lock.json and package.json and CHANGELOG.md</span><br><span class="line">✔ tagging release v2.0.3</span><br><span class="line">ℹ Run `git push --follow-tags origin master &amp;&amp; npm publish` to publish</span><br></pre></td></tr></table></figure><p><strong>常用命令：</strong></p><ul><li>standard-version –first-release // 为第一个版本生成CHANGELOG</li><li>standard-version –release-as 1.1.0  // 自定义版本号 =&gt; 1.1.0 </li><li>standard-version –release-as major // 强制大版本更新 1.1.0 =&gt; 2.0.0</li><li>standard-version –release-as minor // 强制小版本更新 1.1.0 =&gt; 1.2.0</li></ul><p><strong>跳过步骤：</strong></p><p>通过package.json的配置可以跳过任意步骤：bump,changelog, commit, tag</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"standard-version"</span>: &#123;</span><br><span class="line">    <span class="attr">"skip"</span>: &#123;</span><br><span class="line">      <span class="attr">"commit"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines" target="_blank" rel="noopener">angular commit规范</a></p><p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于大小写不敏感的坑</title>
      <link href="/2019/04/19/tool-caseSensitive/"/>
      <url>/2019/04/19/tool-caseSensitive/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>场景：</strong></p><ul><li>新建a.js 文件并使用git提交到远程仓库，再将本地 a.js 更名为 A.js，git却无法识别也无法提交。</li><li><a href="http://www.chengpengfei.com/2018/01/23/" target="_blank" rel="noopener">两人本地存储的是同名不同大小写的文件，导致代码拉取时出现各种问题。</a></li><li>在macOS/windows上解压linux的程序时，同名但大小写不同的文件会互相覆盖。</li><li>一个全小写的文件名，将其引入时路径中的该文件名首字母写成了大写，本地编译时不会报错，但到线上部署时就会构建失败。</li></ul><p><strong>原因：</strong>一般开发使用的macOS/windows系统都是默认不区分文件名大小写的，而用来部署的服务器通常都是使用文件名大小写不敏感的Linux系统。git 为了兼容Windows和MacOS，也是默认不区分文件名大小写的。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="修改系统配置"><a href="#修改系统配置" class="headerlink" title="修改系统配置"></a>修改系统配置</h3><p><a href="https://zhuanlan.zhihu.com/p/35908178" target="_blank" rel="noopener">《在 macOS 中完美配置文件名大小写敏感》</a>这篇文章中提到了两种修改系统配置的方法：</p><ul><li>将macOS 默认『Mac OS 扩展（日志式）』格式的磁盘改成『 Mac OS 扩展（区分大小写，日志式）』。</li><li>添加新的大小写敏感的 APFS 卷宗。</li></ul><p>但这两种方法都不适用于团队，且会导致一些软件无法使用，所以这两种方法还是不要考虑了。</p><h3 id="关于git"><a href="#关于git" class="headerlink" title="关于git"></a>关于git</h3><p><strong>git配置方法：</strong></p><ul><li>全局设置大小写敏感：<code>git config --global core.ignorecase false</code></li><li>单个项目设置大小写敏感：<code>git config core.ignorecase false</code></li></ul><p><strong>但git config core.ignorecase false也有坑</strong>：</p><p>假设甲和乙都在有a.js文件的『分支1』下开发，而丙在更名为A.js的『分支2』下开发且设置了<code>git config core.ignorecase false</code>，当丙在『分支2』下merge『分支1』时，会提示文件将被重写。</p><p><strong>所以当多人协作开发时更推荐进行如下操作：</strong></p><blockquote><p>使用git mv 命令时，会自动执行git add。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git mv -f [要删掉的文件名] [要留下的文件名]</span><br><span class="line">git commit -m <span class="string">"改名"</span></span><br></pre></td></tr></table></figure><p>当已造成了本地一个文件、远程两个同名但大小写不同的文件时，使用此方法也可解决问题。</p><p>参考文章：<a href="https://blog.walterlv.com/post/case-insensitive-in-git-rename.html" target="_blank" rel="noopener">解决 Git 重命名时遇到的大小写不敏感的问题</a></p><h3 id="webpack插件配置"><a href="#webpack插件配置" class="headerlink" title="webpack插件配置"></a>webpack插件配置</h3><p>通过Webpack插件<strong>case-sensitive-paths-webpack-plugin</strong>来强制区分引入文件的路径大小写，在本地编译时就能及时发现问题，杜绝第四个问题场景的出现。</p><p>npm地址：<a href="https://www.npmjs.com/package/case-sensitive-paths-webpack-plugin" target="_blank" rel="noopener">https://www.npmjs.com/package/case-sensitive-paths-webpack-plugin</a></p><p><strong>第一步：安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev <span class="keyword">case</span>-sensitive-paths-webpack-plugin</span><br></pre></td></tr></table></figure><p><strong>第二步：配置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CaseSensitivePathsPlugin = <span class="built_in">require</span>(<span class="string">'case-sensitive-paths-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpackConfig = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">// 若想调试可用new CaseSensitivePathsPlugin(&#123;debug: true&#125;)</span></span><br><span class="line">        <span class="keyword">new</span> CaseSensitivePathsPlugin()</span><br><span class="line">        <span class="comment">// 其他插件 ...</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// 其他webpack配置项 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了避免大小写引来的各种问题，个人比较建议：</p><ul><li>制定文件命名规范，统一为小驼峰式。</li><li>统一安装case-sensitive-paths-webpack-plugin插件。</li><li>若想修改已提交的文件名称大小写，务必使用<code>git mv -f [要删掉的文件名] [要留下的文件名]</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logLevel</title>
      <link href="/2019/04/19/tool-logLevel/"/>
      <url>/2019/04/19/tool-logLevel/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>相关链接：<ul><li><a href="https://www.npmjs.com/package/loglevel" target="_blank" rel="noopener">https://www.npmjs.com/package/loglevel</a></li><li><a href="https://github.com/pimterry/loglevel" target="_blank" rel="noopener">https://github.com/pimterry/loglevel</a></li></ul></li><li>推荐理由：<ul><li>使用本插件的项目众多，包括webpack-dev-server等。</li><li>轻量、跨平台、兼容性强，基本功能都有，也比较干净。</li><li>2013年创建的，一直有在维护，issue中也看出来作者比较靠谱。</li></ul></li></ul><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install loglevel --save</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 module</span></span><br><span class="line"><span class="keyword">import</span> log <span class="keyword">from</span> <span class="string">'loglevel'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonsJS (e.g. Node)</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">require</span>(<span class="string">'loglevel'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD (e.g. RequireJS)</span></span><br><span class="line">define([<span class="string">'loglevel'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">log</span>) </span>&#123;</span><br><span class="line">   log.warn(<span class="string">"dangerously convenient"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接引入</span></span><br><span class="line">&lt;script src=<span class="string">"loglevel.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="level"><a href="#level" class="headerlink" title="level"></a>level</h3><p>5种常规log，级别从低到高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.trace(msg) <span class="comment">// 跟踪记录信息，和debug类似，级别最低</span></span><br><span class="line">log.debug(msg) <span class="comment">// debug调试信息，同log.log(msg)</span></span><br><span class="line">log.info(msg)  <span class="comment">// 提示说明性信息</span></span><br><span class="line">log.warn(msg)  <span class="comment">// 警告，潜在错误信息</span></span><br><span class="line">log.error(msg) <span class="comment">// 错误事件信息</span></span><br></pre></td></tr></table></figure><p>相关函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 禁用所有低于给定级别的日志，默认为warn</span></span><br><span class="line"><span class="comment">- 第一个参数为级别(level):</span></span><br><span class="line"><span class="comment">      - 可为字符串：trace、debug、info、warn、error、silent（不区分大小写）；</span></span><br><span class="line"><span class="comment">      - 可为数字：0到5(trace到silent)；</span></span><br><span class="line"><span class="comment">      - 亦可为内置变量(例如log.levels.DEBUG)</span></span><br><span class="line"><span class="comment">- 第二个参数为持久化选项:</span></span><br><span class="line"><span class="comment">      - loglevel会尽可能使用LocalStorage和cookies来实现持久化</span></span><br><span class="line"><span class="comment">      - 若两者都无法使用或persist设为false，将不会使用存储。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">log.setLevel(level, [persist])</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置默认级别，参数同setLevel */</span></span><br><span class="line">log.setDefaultLevel(level)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启用所有日志消息,等同于log.setLevel("trace") */</span></span><br><span class="line">log.enableAll()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 禁用所有日志消息,等同于log.setLevel("silent") */</span></span><br><span class="line">log.disableAll()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回当前日志级别，从0到5(trace到silent) 的数字 */</span></span><br><span class="line">log.getLevel()</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建新的logger对象，可以单独为其设置级别和方法 */</span></span><br><span class="line">log.getLogger(loggerName)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回所有使用getLogger创建的Logger对象 */</span></span><br><span class="line">log.getLoggers()</span><br></pre></td></tr></table></figure><h3 id="methodFactory"><a href="#methodFactory" class="headerlink" title="methodFactory"></a>methodFactory</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">- 每次设置级别（包括初始化）时，都会运行methodFactory方法进行重置</span></span><br><span class="line"><span class="comment">- 可在此函数中，对输出日志进行格式化或异步处理</span></span><br><span class="line"><span class="comment">- 最后务必调用setLevel方法以使其生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> originalFactory = log.methodFactory;</span><br><span class="line">log.methodFactory = <span class="function"><span class="keyword">function</span> (<span class="params">methodName, logLevel, loggerName</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> rawMethod = originalFactory(methodName, logLevel, loggerName);</span><br><span class="line"><span class="comment">// 在每条输出的日志前加上"Newsflash: "前缀</span></span><br><span class="line"><span class="comment">// 要注意传多个参数的情况 https://github.com/pimterry/loglevel/issues/86</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> argsArray = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">argsArray.unshift(<span class="string">"Newsflash: "</span>);</span><br><span class="line">rawMethod.apply(<span class="keyword">this</span>, argsArray);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">log.setLevel(log.getLevel());</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若与其他库冲突，可使用noConflict函数，并使用其他名字命名</span></span><br><span class="line"><span class="keyword">var</span> logging = log.noConflict();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个对象：&#123; TRACE: 0, DE<span class="doctag">BUG:</span> 1, INFO: 2, WARN: 3, ERROR: 4, SILENT: 5 &#125;</span></span><br><span class="line">log.levels</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>模块的使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 module-one.js 文件中:</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">require</span>(<span class="string">"loglevel"</span>).getLogger(<span class="string">"module-one"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingAmazing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  log.debug(<span class="string">"Amazing message from module one."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 module-two.js 文件中:</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">require</span>(<span class="string">"loglevel"</span>).getLogger(<span class="string">"module-two"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingSpecial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  log.debug(<span class="string">"Special message from module two."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main.js 文件中:</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">require</span>(<span class="string">"loglevel"</span>);</span><br><span class="line"><span class="keyword">var</span> moduleOne = <span class="built_in">require</span>(<span class="string">"module-one"</span>);</span><br><span class="line"><span class="keyword">var</span> moduleTwo = <span class="built_in">require</span>(<span class="string">"module-two"</span>);</span><br><span class="line">log.getLogger(<span class="string">"module-two"</span>).setLevel(<span class="string">"TRACE"</span>);</span><br><span class="line"></span><br><span class="line">moduleOne.doSomethingAmazing(); </span><br><span class="line">moduleTwo.doSomethingSpecial(); </span><br><span class="line"><span class="comment">// 控制台中只输出了 "Special message from module two."，因为moduleOne设置的级别为默认的‘warn’</span></span><br></pre></td></tr></table></figure><p><strong>在浏览器环境下，为日志添加样式及执行异步操作</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ES6 module</span></span><br><span class="line"><span class="keyword">import</span> log <span class="keyword">from</span> <span class="string">'loglevel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 美化样式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColor</span>(<span class="params">message, methodName, loggerName</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> mapping = &#123; <span class="attr">trace</span>: <span class="string">'#389e0d'</span>, <span class="attr">debug</span>: <span class="string">'#f70'</span>, <span class="attr">info</span>: <span class="string">'#1890FF'</span> &#125;;</span><br><span class="line"><span class="comment">// 仅适用于浏览器环境</span></span><br><span class="line"><span class="keyword">if</span> (mapping[methodName] &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line"><span class="string">`%c<span class="subst">$&#123;methodName&#125;</span>-<span class="subst">$&#123;loggerName || <span class="string">'Global'</span>&#125;</span>`</span>,</span><br><span class="line"><span class="string">`background: <span class="subst">$&#123;mapping[methodName]&#125;</span>;color: #fff;padding: 3px 5px;margin-right: 5px`</span>,</span><br><span class="line">].concat(message);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟异步请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendLogMsg</span>(<span class="params">message, methodName, loggerName</span>) </span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'已发送'</span>, message, methodName, loggerName);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 自定义logger函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initLogger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> originalFactory = log.methodFactory;</span><br><span class="line">log.methodFactory = <span class="function">(<span class="params">methodName, logLevel, loggerName</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> rawMethod = originalFactory(methodName, logLevel, loggerName);</span><br><span class="line"><span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 在箭头函数中call和apply会忽略第一个参数，故不用箭头函数</span></span><br><span class="line"><span class="keyword">let</span> logMsg = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 模拟上报日志</span></span><br><span class="line">that.sendLogMsg(logMsg, methodName, loggerName);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">rawMethod.apply(<span class="keyword">this</span>, that.setColor(logMsg, methodName, loggerName));</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 应用自定义methodFactory函数</span></span><br><span class="line">log.setLevel(process.env.NODE_ENV === <span class="string">'development'</span> ? <span class="number">0</span> : <span class="string">'warn'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在node环境下，为日志添加样式</strong></p><p>着色插件：<a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">https://github.com/chalk/chalk</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="built_in">require</span>(<span class="string">'loglevel'</span>); </span><br><span class="line"><span class="keyword">var</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeLog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">log.setLevel(<span class="number">0</span>);</span><br><span class="line">log.info(chalk.white.bgGreen.bold(<span class="string">'Hello world!'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《现代前端技术解析》笔记</title>
      <link href="/2019/01/19/book-technology/"/>
      <url>/2019/01/19/book-technology/</url>
      
        <content type="html"><![CDATA[<p>本文是我阅读<a href="https://book.douban.com/subject/27021790/" target="_blank" rel="noopener">《现代前端技术解析》</a>过程中记录下来的笔记。这是一本以现代前端技术思想与理论为主要内容的书，在前端知识体系上做了很好的总结和梳理，涵盖了现代前端技术绝大部分的知识内容，包括<a href="/2019/01/19/FE-technology/#浏览器基础知识">浏览器基础知识</a>、<a href="/2019/01/19/FE-technology/#前端相关协议">前端相关协议</a>、<a href="/2019/01/19/FE-technology/#三层结构演进与实践">三层结构演进与实践</a>、<a href="/2019/01/19/FE-technology/#前端交互框架">前端交互框架</a>、<a href="/2019/01/19/FE-technology/#前端项目与技术实践">前端项目与技术实践</a>、<a href="/2019/01/19/FE-technology/#前端跨栈技术">前端跨栈技术</a>等。</p><a id="more"></a><h2 id="浏览器基础知识"><a href="#浏览器基础知识" class="headerlink" title="浏览器基础知识"></a>浏览器基础知识</h2><h3 id="用户输入一个网址到页面展示内容的这段时间内，浏览器和服务器都发生了什么事情？"><a href="#用户输入一个网址到页面展示内容的这段时间内，浏览器和服务器都发生了什么事情？" class="headerlink" title="用户输入一个网址到页面展示内容的这段时间内，浏览器和服务器都发生了什么事情？"></a>用户输入一个网址到页面展示内容的这段时间内，浏览器和服务器都发生了什么事情？</h3><ul><li>在接收到用户输入的网址后，浏览器会开启一个线程来处理这个请求，对用户输入的URL地址进行分析判断，如果是HTTP协议就按照 HTTP方式来处理。</li><li>调用浏览器引擎中的对应方法，比如WebView中的loadUrl方法，分析并加载这个URL地址。</li><li>通过DNS解析获取该网站对应的IP地址，查询完成后联同浏览器的COOKIE、userAgent等信息向网站目的IP发出GET请求。</li><li>进行HTTP协议会话，浏览器客户端向Web服务器发送报文。</li><li>进入网站后台的Web服务器处理请求，如Apache、Tomcat、Node.js等服务器。</li><li>进入部署好的后端应用，如PHP、Java、Javascript、Python等后端程序，找到对应的请求处理逻辑，这期间可能会读取服务器缓存或查询数据库。</li><li>服务器处理请求并返回响应报文，此时如果浏览器访问过该页面，缓存上有对应的资源，会与服务器最后修改记录对比，一致则返回304，否则返回200和对应的内容。</li><li>浏览器开始下载HTML文档（响应报头状态码为200时）或者从本地缓存读取文件内容（浏览器缓存有效或响应报头状态码为304时）。</li><li>浏览器根据下载接收到的HTML文件解析结构建立DOM（Document Object Model，文档对象模型）文档树，并根据HTML中的标记请求下载指定的MIME类型文件（如CSS、Javascript脚本等），同时设置缓存等内容。</li><li>页面开始解析渲染DOM，CSS根据规则解析并结合DOM文档树进行网页内容布局和绘制渲染，Javascript提供DOM API操作 DOM,并读取浏览器缓存、执行事件绑定等，页面整个展示过程完成。</li></ul><h3 id="浏览器渲染引擎工作流程"><a href="#浏览器渲染引擎工作流程" class="headerlink" title="浏览器渲染引擎工作流程"></a>浏览器渲染引擎工作流程</h3><ul><li><strong>解析HTML构建DOM树</strong>：解析通过网络模块下载的HTML文件，将HTML元素标签解析成由多个DOM元素对象节点组成的具有节点父子关系的DOM树结构。</li><li><strong>构建渲染树(render tree)</strong>：根据DOM树结构的每个节点顺序提取计算使用的CSS规则并重新计算DOM树结构的样式数据，生成一个带样式描述的DOM渲染树对象。</li><li><strong>渲染树的布局</strong>：根据每个渲染树节点在页面中大小和位置，将节点固定到页面的对应位置上。元素的布局属性生效，如position、float、margin等属性。</li><li><strong>绘制渲染树</strong>：将渲染树节点的背景、文本等样式信息应用到每个节点上。元素内部显示样式生效，如color、text-shadow等属性。</li></ul><h3 id="浏览器数据持久化存储技术"><a href="#浏览器数据持久化存储技术" class="headerlink" title="浏览器数据持久化存储技术"></a>浏览器数据持久化存储技术</h3><ul><li>http文件缓存：强缓存（200 from cache）与协商缓存（304）<ul><li>属于强缓存控制的：（http1.1）Cache-Control/Max-Age、（http1.0）Pragma/Expires</li><li>属于协商缓存控制的：（http1.1）If-None-Match/E-tag、 （http1.0）If-Modified-Since/Last-Modified</li></ul></li><li>本地存储小容量：Cookie、LocalStorage、SessionStorage。<ul><li>cookie：<ul><li>在设置的过期时间之前一直有效，即使窗口或浏览器关闭。</li><li>cookie数据不能超过4k，只适合保存很小的数据，且有个数限制（各浏览器不同），一般不能超过20个。</li><li>与服务器端通信，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。</li><li>在所有同源窗口中都是共享的。</li><li>缺点：需要程序员自己封装，源生的Cookie接口不友好；浪费宽带。</li><li>备注：被设置为HttpOnly的cookie不能被JS读取，保证了安全性。</li></ul></li><li>localStorage（本地存储）：<ul><li>数据有效期是永久，浏览器关闭后数据不丢失除非主动删除数据。</li><li>存放数据大小为一般为2MB到5MB不等，不同浏览器各不相同。</li><li>不参与和服务器的通信。</li><li>在所有同源窗口中都是共享的。</li><li>缺点：在浏览器的隐私模式下和存满时会报错；可被js访问，易受到XSS攻击。</li></ul></li><li>sessionStorage（会话存储）：<ul><li>在当前浏览器窗口关闭后自动删除。</li><li>存放数据大小为一般为2MB到5MB不等，不同浏览器各不相同。</li><li>不参与和服务器的通信。</li><li>同一会话时间内单标签页同域下的不同页面之间共享；</li><li>缺点：在浏览器的隐私模式下和存满时会报错；可被js访问，易受到XSS攻击。</li></ul></li></ul></li><li>本地存储大容量：WebSql和IndexDB主要用在前端有大容量存储需求的页面上，例如，在线编辑浏览器或者网页邮箱。<ul><li>webSql是关系型数据库，已被W3C标准废弃。</li><li>IndexDB是非关系数据库，可正常使用。</li></ul></li><li>manifest离线配置：Manifest是H5提供的一种应用缓存机制，基于它web应用可以实现离线访问(offline cache)，主要是通过manifest文件来标注要被缓存的静态文件清单，是一个被W3C标准废弃的功能。</li><li>cacheStorage：用于保存Service Worker声明的cache对象，ServiceWorker和WebWorker一样是浏览器后台独立的线程。这种方式可利用浏览器本身机制来实现离线缓存，但兼容性很差，暂不成熟。</li><li>flash缓存：少用，可忽视。</li></ul><h2 id="前端相关协议"><a href="#前端相关协议" class="headerlink" title="前端相关协议"></a>前端相关协议</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul><li>HTTP（超文本传输协议）协议是WWW服务器和用户请求代理（如浏览器）之间通过应答请求模式传输超文本（如HTML、JS文件、接口数据等）内容的一种协议。</li><li>浏览器发送请求报文，服务器发送响应报文。</li><li>通常一个完整的HTTP报文由头部、空行（用于区分头部和正文，由回车符和换行符组成）、正文组成。</li><li>HTTP协议先后经历了HTTP0.9、HTTP1.0、HTTP1.1和HTTP2四个版本。目前最为广泛的是HTTP1.1。</li></ul><h4 id="HTTP1-0重要特性"><a href="#HTTP1-0重要特性" class="headerlink" title="HTTP1.0重要特性"></a>HTTP1.0重要特性</h4><ul><li><strong>无连接</strong>：浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接。缺陷是无法复用连接。</li><li><strong>无状态</strong>：服务器不跟踪每个客户端也不记录过去的请求。</li><li><strong>三种请求方法</strong>：只有三个，GET、POST、HEAD</li></ul><h4 id="HTTP1-1重要特性"><a href="#HTTP1-1重要特性" class="headerlink" title="HTTP1.1重要特性"></a>HTTP1.1重要特性</h4><ul><li><strong>长连接</strong>：通过设置请求头Connection：keep-alive来控制，可以让客户端到服务器端之间的连接在一段时间内持续有效。用于传输HTTP数据的TCP连接建立后不会关闭，客户端再次访问服务器时，会复用已建立的连接。</li><li><strong>协议扩展切换</strong>：通过请求头中的Upgrade控制，让客户端通过头部标识令服务器知道它能够支持其他备用通信协议的一种机制。如WebSocket协议通信是通过HTTP方式建立的，通过在请求头中设置Upgrade为WebSocket，来通知服务器在通信连接建立后切换到WebSocket协议来完成后面的数据通信。</li><li><strong>缓存控制</strong>：强缓存通过Cache-Control：Max-Age来控制，协商缓存通过If-None-Match/E-tag来控制。</li><li><strong>部分文件传输优化</strong>：可以支持超文本文件的部分传输。</li><li><strong>host头域</strong>：使得一个服务器能够用来创建多个Web站点</li><li><strong>新增请求方法</strong>：PUT、DELETE、OPTIONS、CONNECT、TRACE</li></ul><h4 id="HTTP2-0重要特性"><a href="#HTTP2-0重要特性" class="headerlink" title="HTTP2.0重要特性"></a>HTTP2.0重要特性</h4><blockquote><p>http2.0不是https，它相当于是http的下一代规范。如果http2.0全面应用，很多http1.1中的优化方案就无需用到，如精灵图、静态资源多域名拆分、CSS和JS放置位置等。</p></blockquote><ul><li><strong>流式传输</strong>：采用完全二进制的格式传输数据，在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量。</li><li><strong>首部压缩</strong>：http头部压缩，减少体积，最大限度节省传输带宽。</li><li><strong>多路复用/连接共享</strong>：不同文件的传输帧可以在一个tcp/ip连接中一起同时进行流式传输。基于“二进制分帧”的特性实现了真正的并行传输，能够在一个TCP上进行任意数量HTTP请求。</li><li><strong>传输优先级</strong>：服务器会保证优先级高的文件流先传输。</li><li><strong>服务器端推送</strong>：除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。即可以主动通知客户端。</li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTPS概述"><a href="#HTTPS概述" class="headerlink" title="HTTPS概述"></a>HTTPS概述</h4><ul><li>HTTP + 加密 + 认证 + 完整性保护 = HTTP + SSL/TLS证书 = HTTPS</li><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全，对搜索引擎更友好，利于SEO。</li><li>公钥和私钥是通过一种加密算法得到的密钥对，公钥常用于会话加密、验证数字签名或加密可以用相应私钥解密的数据。密钥对是唯一的。用公钥加密数据只能用私钥解密，私钥加密只能用公钥解。</li></ul><h4 id="HTTPS双向的加密传输连接"><a href="#HTTPS双向的加密传输连接" class="headerlink" title="HTTPS双向的加密传输连接"></a>HTTPS双向的加密传输连接</h4><ul><li>客户端告诉服务端将建立HTTPS连接。</li><li>服务器生成公钥返回给客户端，同时要求客户端进行连接验证。</li><li>客户端将服务器公钥加密过的验证串和客户端公钥发给服务器。</li><li>服务器使用服务器私钥解密报文获得验证串，再将验证串通过客户端公钥加密后返回给客户端。</li><li>客户端通过客户端私钥解密验证串，判断是否为最开始发送的验证串。</li><li>正确则安全，客户端开始将后面的数据通过服务器公钥加密发送给服务端，服务器不断解密获取报文，并通过客户端公钥加密响应报文返回给客户端。</li></ul><h3 id="常见攻击方式"><a href="#常见攻击方式" class="headerlink" title="常见攻击方式"></a>常见攻击方式</h3><ul><li><strong>XSS</strong>：跨站脚本（Cross-site scripting）<ul><li>是注入攻击的一种，带有页面可解析内容的数据未经过处理直接插入到页面上解析。常见的是前端提交的数据未经处理直接存入数据库，后又通过前端读取回显到浏览器。例如发布评论。除了上述的存储型XSS，还有反射型XSS（URL参数注入）、DOM XSS（DOM属性注入）。</li><li>防御方式：对输入到页面的所有内容来源数据进行验证过滤，可用正则、替换标签的方式进行转码或解码。</li></ul></li><li><strong>SQL注入</strong><ul><li>页面提交数据到服务端后，在服务器端未进行数据验证就将数据拼接到SQL语句中执行。</li><li>防御方式：对前端网页提交的数据内容进行严格的检查校验。</li></ul></li><li><strong>CSRF</strong>：跨站请求伪造（Cross-site request forgery）<ul><li>是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。冒充用户发起请求（在用户不知情的情况下）,完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。</li><li>通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]</li><li>防御方式：1、验证HTTP Referer字段；2、加密计算的token验证；3、在HTTP头中自定义属性并验证</li></ul></li><li><strong>网络劫持攻击</strong>：<ul><li>一般指网站资源请求在请求过程中因为人为的攻击导致没有加载到预期的资源内容。主要分为DNS劫持（篡改域名解析结果）与HTTP劫持（劫持请求返回的数据包）。</li><li>防御方式：使用HTTPS协议来访问目标网站。</li></ul></li></ul><h3 id="实时协议"><a href="#实时协议" class="headerlink" title="实时协议"></a>实时协议</h3><ul><li><strong>WebSocket通信机制</strong>：是浏览器和服务器之间的双向数据实时通信的一种协议。但低版本浏览器存在兼容性问题。</li><li><strong>HTTP 2.0</strong>：HTTP 2也支持服务端的消息推送。但目前还未普及。</li><li><strong>poll轮询</strong>：浏览器采用定时向服务器发送请求轮询的方法不断发送或拉取消息。但实时性较差，也比较消耗系统资源。</li><li><strong>long-poll长轮询</strong>：对HTTP请求设置较长的Timeout等待时间，网络轮询请求就可以维持一段较长的时间，服务器如果在这段时间内进行了响应，请求便会立即返回结果，若未响应，浏览器将自动响应超时并重新发起一个长轮询请求。</li></ul><h3 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h3><ul><li><strong>DDP协议（分布式数据协议）</strong>：使用JSON数据格式在客户端和服务器之间进行数据传输通信，新型的实时通信协议。目前存在兼容性问题，未被广泛使用。</li><li><strong>RESTful数据协议规范</strong>：软件架构之间交互调用数据的协议风格规范，建议以一种通用的方式来定义和管理数据交互调用接口。它可以让数据交互的方式更加规范化，一定程素上有利于较低项目开发和维护成本。</li></ul><h3 id="与Native交互协议"><a href="#与Native交互协议" class="headerlink" title="与Native交互协议"></a>与Native交互协议</h3><h4 id="Hybrid-App概述"><a href="#Hybrid-App概述" class="headerlink" title="Hybrid App概述"></a>Hybrid App概述</h4><p>Hybrid App是在Native App应用（原生应用）的基础上结合了Web App应用所形成的模式，称之为混合APP。</p><p><strong>相比于传统的桌面浏览器端的Web App，它具有以下特点：</strong></p><ul><li><strong>可用系统网络资源少</strong>。这是由于移动设备CPU、内存、网卡、网络连接多方面的限制。</li><li><strong>支持更新的浏览器特性</strong>。智能设备浏览器种类较少，以webkit内核居多，不用考虑低版本IE兼容。</li><li><strong>可实现离线应用</strong>。可以通过新浏览器特性或Native文件读取机制进行文件级的文件缓存和离线更新。</li><li><strong>较多的机型考虑</strong>。由于目前移动设备平台的不统一性，需要考虑不同设备机型的兼容性问题。</li><li><strong>支持与Native交互</strong>。可以在前端页面中调用客户端Native的能力。</li></ul><h4 id="Web到Native协议调用"><a href="#Web到Native协议调用" class="headerlink" title="Web到Native协议调用"></a>Web到Native协议调用</h4><p>在HTML5中调用Native程序一般有两种通用方法：</p><ul><li>通过URL请求：Native应用向移动端系统注册schema协议的URI供JS调用。</li><li>通过addJavascriptInterface注入方法到页面中调用：Native向webView全局作用域中注入一个native全局对象，供JS调用。主要原理是通过addJavascriptInterface将Java的实例对象注入到WebView中。</li></ul><h4 id="Native到Web协议调用"><a href="#Native到Web协议调用" class="headerlink" title="Native到Web协议调用"></a>Native到Web协议调用</h4><p>在Native中调用HTML5中JavaScript方法或指令一般有两种通用方法：</p><ul><li>通过loadUrl方法：在H5页面全局作用域中添加方法，类似于schema协议。Android平台下叫loadUrl，IOS系统下通常为stringByEvaluatingJavaScriptFromString。</li></ul><h4 id="JSBridge设计规范"><a href="#JSBridge设计规范" class="headerlink" title="JSBridge设计规范"></a>JSBridge设计规范</h4><ul><li>在Android平台下，通常使用JSBridge来定义前端与Native的相互调用协议。</li><li>通过一个协议串定义数据通信规则，如：jsbridge://className:callbackMethod/methodName?jsonObj</li><li>协议串必须包括：调用Native APP的特定标识头、类名称、方法名、参数、回调JavaScript的方法</li><li>以Android为例，前端使用prompt传入协议串来注册类和方法，Native端使用loadUrl(‘javascript:callbackMethod()’)来调用</li></ul><h2 id="三层结构演进与实践"><a href="#三层结构演进与实践" class="headerlink" title="三层结构演进与实践"></a>三层结构演进与实践</h2><blockquote><p>前端的三个基本构成：HTML结构层、CSS表现层、JavaScript行为层</p></blockquote><h3 id="HTML结构层基础"><a href="#HTML结构层基础" class="headerlink" title="HTML结构层基础"></a>HTML结构层基础</h3><ul><li><strong>DOCTYPE</strong><ul><li>处于HTML文档的头部的&lt;!DOCTYPE&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令，指示web浏览器使用对应的HTML版本编写的只能进行解析。</li><li>由于HTML4.01基于SGML（标准通用标记语言），所以在HTML4.01中&lt;!DOCTYPE&gt;声明指向一个DTD（文档类型定义），DTD指定了标记规则以保证浏览器正确渲染内容。HTML5不基于SGML，所以不用指定DTD。</li><li>&lt;!DOCTYPE html&gt;兼容所有HTML的历史版本和最新的HTML5版本。如果DOCTYPE不存在或格式错误，文档会以兼容模式呈现，浏览器会使用较低的标准模式来解析HTML。</li></ul></li><li><strong>web语义化标签</strong>：web语义化是指在HTML结构的恰当位置上使用语义恰当的标签，使页面具有良好的结构，使页面标签元素具有含义，能够让人或搜索引擎更容易理解。</li><li><strong>HTML糟糕的部分</strong><ul><li>有些HTML5新语义化标签会存在兼容性问题，仍需使用div标签替代。</li><li>table标签性能存在问题，因为table内容渲染是等表格内容全部解析完生成渲染树后一次性渲染到页面上的。通常使用其他方式模拟table元素。</li><li>HTML标签随意添加属性、CSS属性使用错误等情况不会报错。通常需要借助插件或者构建工具来辅助开发。</li></ul></li><li><strong>AMP HTML</strong><ul><li>流动网页提速(AMP)是Google推行的一个提升页面资源载入效率的HTML提议规范。</li><li>基本思路：<strong>使用严格受限的高效HTML标签</strong>以及<strong>使用静态网页缓存技术</strong>来提高网络访问静态资源的性能和用户体验。</li></ul></li><li><strong>关于XML</strong><ul><li>是可扩展性标记语言，一种重量级的数据交换格式语言，基于SGML，类似HTML。</li><li>设计宗旨是传输数据，而非显示数据。</li><li>XML标签没有被预定义，需要自行定义标签。</li><li>XML被设计为具有自我描述性。</li></ul></li><li><strong>Web Component</strong><ul><li><strong>Shadow DOM</strong>是HTML的一个规范，允许浏览器开发者封装自己的HTML标签、CSS样式和特定的JavaScript代码，同时也可让开发者创建类似video这样的自定义一级标签，创建这些新标签内容的技术和相关的API被称为<strong>Web Component</strong>。</li><li>Chrome 31及Android 4.4 以上版本浏览器提供了创建Shadow DOM的API ：document.createShadowRoot()。</li></ul></li></ul><h3 id="JavaScript行为层基础"><a href="#JavaScript行为层基础" class="headerlink" title="JavaScript行为层基础"></a>JavaScript行为层基础</h3><h4 id="前端脚本语言的演进"><a href="#前端脚本语言的演进" class="headerlink" title="前端脚本语言的演进"></a>前端脚本语言的演进</h4><p>演进过程主要包括以下几个阶段：ECMAScript 5、CoffeeScript、ECMAScript 6+、TypeScript和衍生脚本。</p><ul><li><strong>CoffeeScript</strong>重新定义了一套语法规则，使用了更加简洁高效的编码语法，按照统一的规则转译成规范、可读、默认在严格模式下运行的JavaScript代码。它在ES5时代是极具代表性的，但随着更高效的ES6的发布，CoffeeScript走向了没落。</li><li><strong>ES6标准</strong>：是2015年TC39制定的JavaScript规范。在浏览器应用开发中，由于浏览器版本较多，需要将ES6转译为ES5语法运行，ES6只能作为语法糖使用；在Node端的应用开发中，Node环境对新版本特性支持较为完善，大大提高了开发效率。</li><li><strong>TypeScript</strong>：是微软在2012年推出的一种自由开源编程语言，是JavaScript的一个超集，与ES6差异很小，增加了少数特殊应用场景下优势的内容。</li><li><strong>衍生脚本</strong>：基于现有JavaScript的实现扩展自己特有语法规则来适应特殊应用场景的一类脚本规范，即JavaScript的超集。如JSX或HyperScript，CoffeeScript和TypeScript在某种意义上也是JavaScript的衍生脚本。</li></ul><h4 id="ES5特性"><a href="#ES5特性" class="headerlink" title="ES5特性"></a>ES5特性</h4><ul><li><strong>严格模式</strong>：限制了原有一些不规范的写法，让一些不合理的语法直接报错，从而提高了代码的安全性和规范性。对全局变量、with、eval、arguments、var等方面进行了限制，消除了JS语法一些不合理、不严谨之处。</li><li><strong>内置JSON对象</strong>：内置了JSON对象，用于JSON对象和JSON字符串之间的转换操作，不再需要用第三方库来转换。</li><li><strong>新增Object方法属性</strong>：如getPrototypeOf(返回原型)、create(创建对象)、defineProperty(用于数据劫持)、freeze(冻结对象)等</li><li><strong>新增Array方法属性</strong>：indexOf(返回索引值)、forEach(遍历执行)、map(返回处理过的数组)、reduce(累加器)等</li><li><strong>新增bind()、trim()、Date.now()等实用函数</strong>：Function.prototype.bind()用于将当前函数和指定对象绑定并返回新函数，新函数被调用时，代码会在指定对象的上下文中执行；String.prototype.trim()用于去除字符串前后空格；Date.now()会返回当前时间戳。</li></ul><h4 id="ES6特性"><a href="#ES6特性" class="headerlink" title="ES6特性"></a>ES6特性</h4><ul><li><strong>块级作用域变量</strong>：声明关键字let和const。</li><li><strong>字符串模板</strong>：使用倒引号<code></code>拼接字符串，用${expression} 表示占位符。</li><li><strong>解构赋值</strong>：例如const [x, y, z] = point或const {x, y, z} =  point。</li><li><strong>数组新特性</strong>：如Array.from、Array.key、Array.prototype.copyWithin等。</li><li><strong>函数参数</strong>：函数添加了默认参数、不定参数和拓展参数的设计。</li><li><strong>箭头函数</strong>：不需要 function 关键字来创建函数，省略 return 关键字，继承当前上下文的 this 关键字。</li><li><strong>增强对象</strong>：可以在定义对象时通过属性简写、变量作为属性名、省略对象函数属性的书写等方式提高编码效率。</li><li><strong>Class（类）</strong>：只是个语法糖，实际上还是原型继承，通过extends关键字实现继承。实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</li><li><strong>模块化</strong>：通过export暴露接口，通过import引用其他文件的内容。</li><li><strong>循环与迭代器</strong>：可使用for…in遍历对象，使用for…of遍历数组、Map、Set等合集。interator迭代器则可以控制单步循环触发的时机。</li><li><strong>Generators(生成器)</strong>：是能返回一个迭代器的函数。比普通的function多了个星号*，在其函数体内可以使用yield关键字，会在每个yield后暂停，调用next()方法继续。</li><li><strong>集合类型Map + Set + weakMap + WeakSet</strong>：集合类型是对对象的增强类型，是一类是数据管理操作更加高效的对象类型。</li><li><strong>Promise、Symbol、Proxy增强类型</strong>：Promise可以用同步的方式去写异步代码，ES6遵守的是Promise/A+规范；Symbol是ES6新增的基本数据类型，一般用作属性键值，并且能避免对象属性键的命名冲突；Proxy可以用来拦截某个对象的属性访问方法，和ES5的defineProperty相似。</li><li><strong>统一码</strong>：ES6字符串支持新的Unicode文本形式，也增加了新的正则表达式修饰符u来处理统一码。</li><li><strong>进制数支持</strong>：增加了二进制和八进制字面量的支持。</li><li><strong>Reflect对象和tail calls尾调用</strong>：Reflect用于对原有对象进行赋值或取值操作，但不会触发getter或setter调用；tail calls尾调用保证了函数尾部调用时调用栈有一定的长度限制。</li></ul><h4 id="ES7-特性"><a href="#ES7-特性" class="headerlink" title="ES7+特性"></a>ES7+特性</h4><ul><li><strong>幂指数操作符</strong>：新增操作符来进行幂指数运算</li><li><strong>Array.prototype.includes</strong>：用来判断数组中是否包含某个元素。</li><li><strong>异步函数 async/await</strong>：async/await是对Generator的简化封装，专门用于处理异步场景。</li><li><strong>SIMD.JS – SIMD APIs + Polyfill</strong>：指单指令多数据流，涉及并行计算范畴的语法指令。</li></ul><h4 id="TypeScript特性"><a href="#TypeScript特性" class="headerlink" title="TypeScript特性"></a>TypeScript特性</h4><ul><li><strong>是ES6的超集</strong>：就语言特性而言，是ES6的超集，基本包含了ES6和ES6中部分未实现的内容，如async/await。</li><li><strong>强类型支持</strong>：数据类型是强类型的，声明时需要对类型进行定义。</li><li><strong>Decorator装饰器特性</strong>：可以用来注解class、property、method和parameter，也是一种面向对象编程语言设计模式的借鉴。</li></ul><h3 id="CSS表现层基础"><a href="#CSS表现层基础" class="headerlink" title="CSS表现层基础"></a>CSS表现层基础</h3><h4 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h4><ul><li><strong>CSS选择器</strong>：<ul><li>css选择器类别：id选择器、类选择器、元素选择器、组合选择器、伪类、伪元素等。</li><li>选择器属性优先级：!important &gt; 内联样式(权重1000) &gt; ID选择器(权重100)  &gt; 类选择器(权重10)  &gt; 元素选择器(权重1) &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性;</li></ul></li><li><strong>CSS属性</strong>：<ul><li>布局类属性：position类、弹性布局flex、浮动float、对齐align</li><li>几何类属性：盒模型相关（margin、padding、width、height、border）、box-shadow、渐变gradient、background类、transform类</li><li>文本类属性：font类、line-height、color类、text类（text-decoration、text-indent、text-overflow）、white-space、user-select、text-shawdow等</li><li>动画类属性：以CSS3为主的transition、animation等</li><li>查询类：Media query 和 IE Hack等</li></ul></li><li><strong>不同浏览器下CSS样式统一化</strong>：<ul><li>reset：将浏览器中的默认样式全部清除。例如：body, h1{ margin: 0 }</li><li>normalize：在整站样式基本确定的情况下使用同一个默认样式规则。例如：body, h1{ margin: 5px }</li><li>neat：具体需要根据网站的设计特点来确定。例如：body { margin: 0 } h1{ margin: 5px }</li></ul></li><li><strong>CSS预处理</strong>：<ul><li>预处理工具：SASS、LESS、Stylus、postCSS等</li><li>目的：通过编写更高效、易管理的类CSS脚本并将它们自动生成浏览器解析执行的CSS代码，实现高效开发和便捷管理。</li><li>特性：变量声明和计算、语法表达式、函数处理、属性继承、兼容性补全。</li></ul></li></ul><h4 id="实现动画的方案"><a href="#实现动画的方案" class="headerlink" title="实现动画的方案"></a>实现动画的方案</h4><ul><li>JavaScript直接实现：通过setInterval或setTimeout的回调函数来持续调用改变某个元素的CSS样式，一般以16ms为间隔达到60帧。</li><li>SVG(可伸缩矢量图形)：由SVG内部元素（如<set>、<animate>等）的属性控制。</animate></set></li><li>CSS3 transition：只能在某个标签元素样式或状态改变时进行平滑的动画效果过渡。</li><li>CSS3 animation：真正意义上页面内容的动画，通过对关键帧和循环次数的控制能实现很多动画，脱离JS的控制。</li><li>Canvas：通过JavaScript调用Canvas的API控制渲染动画，一般做法是用定时器不断清空画布并重新绘制。</li><li>requestAnimationFrame：是浏览器针对动画专门优化而成的API，原理和定时器类似，通过JS持续循环调用来触发动画动作。</li></ul><p><strong>总结</strong>：PC端推荐JS直接实现或SVG，移动端推荐transition、animation、canvas或requestAnimationFrame。</p><h3 id="响应式页面开发"><a href="#响应式页面开发" class="headerlink" title="响应式页面开发"></a>响应式页面开发</h3><ul><li><strong>响应式设计</strong>：根据不同设备浏览器尺寸或分辨率来展示不同页面结构层、行为层、表现层内容的设计方式。</li><li><strong>主流实现方法</strong>：<ul><li>通过前端或后端判断userAgent来跳转不同的页面完成不同设备浏览器的适配，需要维护两个不同站点来根据用户设备进行对应的跳转。适用于功能复杂但对性能要求较高的站点应用。</li><li>使用media query媒体查询等手段让页面根据不同设备浏览器自动改变页面的布局和显示，不用做跳转。适用于访问量较小、性能要求不高的应用场景。</li></ul></li><li><strong>结构层响应式(HTML内容的自适应渲染)</strong>：<ul><li>前端渲染数据：桌面端和移动端直接加载到的HTML结构是相同的，使用异步的方式加载桌面端或者移动端不同的JS资源列表。</li><li>后端渲染数据：后端根据userAgent直出不同的HTML模板进行渲染。</li><li>结构层媒体响应式：让浏览器上的展示媒体内容（主要指图片）尺寸根据屏幕宽度或分辨率进行自适应调节。</li></ul></li><li><strong>表现层响应式(响应式布局和屏幕适配布局)</strong><ul><li>响应式布局：根据浏览器宽度、分辨率、横竖屏等情况自动改变页面元素的展示。一般通过栅格系统和媒体查询来实现响应式。</li><li>屏幕适配布局：内容按照不同屏幕大小自动等比例缩放。一般通过设置<meta name="viewport">使页面保持内容不缩放、使用rem作为单位来实现适配。</li></ul></li><li><strong>行为层响应式</strong>：与结构层类似，也是通过设备浏览器环境判断来异步加载不同的JS脚本，同样分为前端引入与后端引入。</li></ul><h2 id="前端交互框架"><a href="#前端交互框架" class="headerlink" title="前端交互框架"></a>前端交互框架</h2><h3 id="DOM交互框架-–-jQuery"><a href="#DOM交互框架-–-jQuery" class="headerlink" title="DOM交互框架 – jQuery"></a>DOM交互框架 – jQuery</h3><p>通过原生的DOM API基本可以完成前端页面的任何操作，但开发复杂网站应用，使用原生API开发就显得低效且不易管理。于是jQuery这个典型的DOM交互框架就对六类DOM API进行了封装，方便开发者调用。</p><h4 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h4><table><thead><tr><th>类型</th><th>常见DOM API</th><th>常见jQuery API</th></tr></thead><tbody><tr><td>节点查询型</td><td>getElementById、getElementsByName(ClassName、TagName)、querySelector、querySelectorAll</td><td>$(selector)、find()等</td></tr><tr><td>节点创建型</td><td>createElement、createDocumentFragment、createTextNode、cloneNode</td><td>$(html)、clone()等</td></tr><tr><td>节点修改型</td><td>appendChild、replaceChild、removeChild、insertBefore、innerHTML</td><td>html()、replace()、remove()、append()、before()、after()等</td></tr><tr><td>节点关系型</td><td>parentNode、previousSibling、childNodes</td><td>parent()、sibling()、child()、closest()、next()等</td></tr><tr><td>节点属性型</td><td>innerHTML、attributes、getAttribute、setAttribute、getComputedStyle</td><td>attr()、data()、css()、hide()、show()、slideDown()、slideUp()、animate()等</td></tr><tr><td>内容加载型</td><td>XMLHttpRequest、ActiveX</td><td>ajax()、get()、post()等</td></tr></tbody></table><h4 id="JQuery-1-X版本-最为广泛-特性"><a href="#JQuery-1-X版本-最为广泛-特性" class="headerlink" title="JQuery 1.X版本(最为广泛)特性"></a>JQuery 1.X版本(最为广泛)特性</h4><ul><li>简化了选择器，可调用$()、find等API以简短的形式进行组合查询。</li><li>扩展实现了如html()、append、animate()等多种类型的DOM操作方法。</li><li>实现了对XMLHttpRequest和ActiveX的统一封装，使AJAX网络请求的调用更加方便。</li><li>对DOM添加了on等方法来统一处理事件，包括事件绑定和事件代理等。</li><li>添加了$.Deferred对象来处理异步回调嵌套问题，借鉴了Promise/A规范。</li><li>做到了兼容性问题对开发者的透明。例如实现事件绑定、AJAX封装时充分考虑了不同浏览器的差异性，并做统一处理。</li></ul><h3 id="MV"><a href="#MV" class="headerlink" title="MV*"></a>MV*</h3><p>随着AJAX技术的盛行，SPA应用开始被广泛使用，但使用JQuery来开发维护SPA应用是比较麻烦的。为了解决这个问题，通常会使用MV*框架。</p><h4 id="常见MV-框架"><a href="#常见MV-框架" class="headerlink" title="常见MV*框架"></a>常见MV*框架</h4><ul><li><strong>MVC框架</strong>：<ul><li>Model-数据模型、View-视图、Controller-控制器</li><li>View 传送指令到 Controller，Controller 完成业务逻辑后，要求 Model 改变状态，Model 将新的数据发送到 View，用户得到反馈。</li><li>一般通过事件监听或观察者模式实现，所有通信都是单向的。</li></ul></li><li><strong>MVP框架</strong>：<ul><li>Model-数据模型、View-视图、Presenter-发布者</li><li>View层将用户交互传递给Presenter，由Presenter完成相应的业务逻辑及对Modal中数据的操作。</li><li>由MVC模式进化而来的，改进了MVC中的控制器过于臃肿的问题。Presenter和View之间的通信是双向的。</li></ul></li><li><strong>MVVM框架</strong>：<ul><li>Model-数据模型、View-视图、ViewModel-视图模型</li><li>用户操作时，ViewModel会捕获数据变化，自动触发Modal的调用和模板内容的渲染。</li><li>可以认为是自动化的MVP框架，将Presenter的工作拆分成多个小指令步骤，通过对指令的识别来渲染数据和绑定事件。</li></ul></li></ul><p><strong>各层解释</strong></p><ul><li>M(Model-数据模型)：用于存放请求的数据结果和数据对象。</li><li>V(View-视图)：用于页面DOM的更新与修改。</li><li>C(Controller-控制器)：实现业务逻辑，根据路由切换页面及数据的增删改查。</li><li>P(Presenter-发布者)：作为中间部分连接View和Model的通信交互完成所有的逻辑操作。</li><li>VM(ViewModel-视图模型)：是视图View的模型、映射和显示逻辑，用来连接数据和视图</li></ul><h4 id="数据变更检测"><a href="#数据变更检测" class="headerlink" title="数据变更检测"></a>数据变更检测</h4><ul><li><strong>手动触发绑定</strong>：在数据对象上定义get()、set()方法，调用时手动触发get和set函数来获取、修改数据，改变数据后悔主动触发get和set函数中View层的重新渲染功能。</li><li><strong>脏数据检测</strong>：在ViewModal对象的某个属性值发送变化时找到与之相关的所有元素，对比数据变化来决定是否重新渲染。最简单的方式就是通过 setInterval() 定时轮询检测数据变动。如Angular.js。</li><li><strong>对象劫持</strong>：使用Object.defineProperty对ViewModal对象进行属性set()、get()的监听，当有数据读取和赋值操作时扫描元素节点，运行指定对应节点的指令。</li><li><strong>Proxy</strong>：Proxy可以用于在已有的对象基础上重新定义一个对象，并重新定义对象原型上的方法，包括get()和set()。</li></ul><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><ul><li><strong>定义</strong>：Virtual DOM是一个能够直接描述一段HTML DOM结构的JavaScript对象。</li><li><strong>核心步骤</strong>：<ul><li>创建Virtual DOM：JS直接解析HTML文本字符串，根据词法分析内容，生成一个JavaScript对象。</li><li>对比新旧Virtual DOM生成差异化的Virtual DOM；</li><li>将差异化的Virtual DOM渲染到页面上。</li></ul></li><li><strong>优点</strong>：减少了对DOM对象的操作，在页面结构变化时进行最小代价的DOM渲染操作，提高交互性能和效率。</li></ul><h3 id="MNV"><a href="#MNV" class="headerlink" title="MNV*"></a>MNV*</h3><ul><li><strong>定义</strong>：使用JavaScript调用原生控件或事件绑定来生成应用程序的交互模式。可以简单理解为Modal-NativeView-*。</li><li><strong>例子</strong>：Modal-NativeView-Virtual DOM 和 Modal-NativeView-ViewModel</li><li><strong>场景</strong>：目前仅适用于移动端Hybrid应用，因为它完全抛弃了DOM，需要依赖原生应用控件的调用支持。</li></ul><h2 id="前端项目与技术实践"><a href="#前端项目与技术实践" class="headerlink" title="前端项目与技术实践"></a>前端项目与技术实践</h2><h3 id="前端规范"><a href="#前端规范" class="headerlink" title="前端规范"></a>前端规范</h3><h4 id="通用规范"><a href="#通用规范" class="headerlink" title="通用规范"></a>通用规范</h4><ul><li>保证结构层(HTML)、表现层(CSS)、行为层(JavaScript)之间的最小耦合。</li><li>统一使用tab或4个空格缩进。</li><li>HTML文档中使用<meta charset="utf-8">指定编码，避免乱码。</li><li>HTML标签、标签属性、样式名及规则建议使用小写，HTML属性id建议使用驼峰命名方式。</li><li>代码单行长度不能超过80或120字符。</li><li>尽可能地为代码写上注释。</li><li>删除行尾空格和多余符号。</li></ul><h4 id="HTML规范"><a href="#HTML规范" class="headerlink" title="HTML规范"></a>HTML规范</h4><ul><li>统一使用HTML5的标准文档类型&lt;!DOCTYPE html&gt;来定义。</li><li>head中必须定义title、keyword、description保证基本SEO页面关键字和内容描述；移动端head添加viewport控制页面不缩放。</li><li>引用CSS或JavaScript时，省略type属性，因为HTML5引入时带默认值。</li><li>所有标签属性值必须用双引号包裹。</li><li>非必须属性值可省略不写。</li><li>所有元素必须正确嵌套，尽量使用语义化标签，不允许交叉，不允许在inline元素中包含block元素。</li><li>非自闭合标签必须添加关闭标识，自闭合标签无须关闭。</li><li>避免img元素的alt属性值为空。</li><li>为表单内部元素\&lt;label>加上for属性或将对应控件放在\&lt;label>标签内部。</li><li>为每个大的模块的开始和结束的地方添加起始注释标记。</li><li>块级元素另起一行写；子元素尽量相对其父级进行缩进。</li><li>在合适的地方选择语义合适的标签。</li></ul><h4 id="CSS规范"><a href="#CSS规范" class="headerlink" title="CSS规范"></a>CSS规范</h4><ul><li>使用link调用外部样式文件，紧张使用内联样式。</li><li>样式命名要统一约定，可使用BEM方案。</li><li>尽量缩写，如单位0不用加单位、URL引用资源不用写引号、颜色值小写并尽量缩写至3位。</li><li>CSS样式书写顺序遵循先写布局属性后写内容属性的规则。</li><li>尽可能减少对CSS Hack的使用和依赖。</li><li>高效实现，如避免标签名与id或class组合的选择器、属性尽可能使用合并写法等。</li><li>使用预处理脚本编码开发。</li></ul><h4 id="ES5常用规范"><a href="#ES5常用规范" class="headerlink" title="ES5常用规范"></a>ES5常用规范</h4><ul><li>JavaScript语句后统一加上分号。</li><li>所有运算符、符号和英文单词之间添加必要的空格，便于阅读。</li><li>推荐在代码块后保留一行空行，使块内容层次分明。</li><li>推荐JavaScript字符串最外层统一使用单引号。</li><li>标准变量采用驼峰式命名；常量使用全大写命名，并用下划线连接；构造函数首字母大写；jQuery对象推荐以$开头命名便于区分。</li><li>对象属性名不需要加引号；对象属性键值以缩进的形式书写；数组、对象属性后不能有都好。</li><li>块代码推荐使用大括号包裹。</li><li>尽量不要直接使用undefined进行变量判断；用===、!\=\=代替\=\=、!==。</li><li>不要在条件语句或循环语句中声明函数。</li></ul><h4 id="ES6-参考规范"><a href="#ES6-参考规范" class="headerlink" title="ES6+参考规范"></a>ES6+参考规范</h4><ul><li>正确使用ES6的let和const。</li><li>字符串拼接使用字符串模板完成。</li><li>解构赋值尽量使用一层解构。</li><li>数组拷贝推荐使用…实现。</li><li>数组循环遍历使用for…of，非必须情况不推荐使用forEach、map、简单循环。</li><li>使用ES6的类来代替之前的类实现方式，尽量使用constructor进行属性成员变量赋值。</li><li>模块化多变量导出时尽量使用对象解构，不使用全局导出。尽量不要把import和export写在一行。</li><li>导出类名时，保持模块名称和文件名相同，类名首字符需要大写。</li><li>生成器中yield进行一步操作时需要使用try…catch包裹，方便对异常进行处理。</li><li>推荐使用promise，避免使用第三方库或直接回调，原生的一步处理性能更好且符合语言规范。</li><li>如果不是必须，避免使用迭代器Iterators。</li><li>不要使用统一码，中文的正则匹配和计算较消耗时间，且容易出问题。</li><li>合理使用Generator，推荐使用async/await。更加简洁。</li></ul><h4 id="前端防御性编程规范"><a href="#前端防御性编程规范" class="headerlink" title="前端防御性编程规范"></a>前端防御性编程规范</h4><ul><li>对外部数据的安全检测判断。</li><li>规范化的错误处理</li></ul><h4 id="前端组件规范"><a href="#前端组件规范" class="headerlink" title="前端组件规范"></a>前端组件规范</h4><ul><li>UI组件规范<ul><li>原则：UI设计一致性、开发实现一致性</li><li>设计实现UI库：统一的页面布局方案、基础UI结构和样式实现、组件化UI结构和样式实现、响应式布局、扩展性。</li></ul></li><li>模块化规范<ul><li>AMD：是运行在浏览器端的模块化异步加载规范，主要以requireJS为代表。基本原理是定义define和require方法异步请求对应的JavaScript模块文件到浏览器端运行。</li><li>CMD：是在浏览器端调用类似commonJS的书写方式进行模块引用的模块化规范，CMD遵循按需执行依赖的原则，只有在用到某个模块时才会执行模块内部的require语句。</li><li>CommonJS：是Node端使用的JavaScript模块化规范，使用require进行模块引入，并使用module.export来定义模块导出。</li><li>import/export：是ES6定义的JavaScript模块引用方式，是唯一一个遵循JavaScript语言标准的模块化规范。</li></ul></li><li>项目组件化设计规范<ul><li>组件化实践方案：Web Component组件化、MVVM框架组件化、Virtual DOM组件化、基于目录管理的通用组件化</li><li>要解决的问题：组件之间独立、松耦合；组件间嵌套使用；组件间通信；公共部分设计；组件构建打包；异步组件的加载模式；组件继承与复用性；私有组件的统一管理；根据特定场景进行扩展或定义。</li></ul></li></ul><h3 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h3><ul><li><strong>目的</strong>：对源项目文件或资源进行文件级处理，将文件或资源处理成需求的最佳输出结构和形式。</li><li><strong>构建原理流程</strong>：读取入口文件 =&gt; 分析模块引用 =&gt; 按照引用加载模块 =&gt; 模块文件编译处理 =&gt; 模块文件合并 =&gt; 文件优化处理 =&gt; 写入生成目录</li><li><strong>构建工具的作用</strong>：<ul><li>模块分析引入</li><li>模块化规范支持</li><li>CSS编译、自动合并图片</li><li>HTML、JavaScript、CSS资源压缩优化</li><li>HTML路径分析替换（将相对路径自动替换成绝对或CDN路径）</li><li>区分开发和线上目录环境</li><li>异步文件打包方案</li><li>文件目录白名单设置</li></ul></li></ul><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><h4 id="前端性能测试"><a href="#前端性能测试" class="headerlink" title="前端性能测试"></a>前端性能测试</h4><ul><li>Performance Timing PAI：描述了页面资源从加载到解析各个阶段的执行关键点时间记录。</li><li>Profile：是Chrome和Firefox等标准浏览器提供的一种用于测试页面脚本运行时系统内存和CPU资源占用情况的API。</li><li>页面埋点计时：通常在移动端使用，找到页面中执行JS耗时的操作，将耗时的执行过程进行埋点计时并上报。</li><li>资源加载时序图：粗粒度地宏观分析浏览器的所有资源文件请求耗时和文件加载顺序情况。</li></ul><h4 id="桌面浏览器前端优化策略"><a href="#桌面浏览器前端优化策略" class="headerlink" title="桌面浏览器前端优化策略"></a>桌面浏览器前端优化策略</h4><ul><li><strong>网络加载类</strong><ul><li>减少HTTP资源请求次数（如合并图片、代码等）</li><li>减少HTTP请求大小（如gzip压缩）</li><li>将CSS或JavaScript放到外部文件（引用外部资源可以有效利用缓存）</li><li>避免页面中空的href和src（为空时仍会去加载）</li><li>为HTML指定Cache-Control或Expires（将HTML内容强缓存）</li><li>合理设置Etag和Last-Modified（使用协商缓存）</li><li>减少页面重定向（重定向会增加时间开销）</li><li>使用静态资源分域存放来增加下载并行数（利用多个域名增加页面加载时资源的并行下载数）</li><li>使用静态资源CDN来存储文件（利用CDN加快同一地理区域内重复静态资源的响应下载速度）</li><li>使用CDN Combo下载传输内容（CDN Combo能将多个文件请求打包成一个文件的形式来返回）</li><li>使用可缓存的AJAX（将ajax的参数cache设为true即可）</li><li>使用GET来完成AJAX请求（使用XMLHttpRequest时，GET只发送头部）</li><li>减少cookie的大小并进行cookie隔离（由于cookie受同源策略限制，且HTTP请求会带上cookie）</li><li>缩小favicon.ico并缓存（因为一般favicon.ico很少改变）</li><li>推荐使用异步JavaScript资源（因为异步JS资源不会阻塞文档解析）</li><li>消除阻塞渲染的CSS及JavaScript（合理拆分或延后加载耗时过长的文件）</li><li>避免使用CSS import引用加载CSS（因为@import会导致串行加载）</li></ul></li><li><strong>页面渲染类</strong><ul><li>把CSS资源引用放到HTML文件顶部（为了优先下载CSS尽早完成渲染）</li><li>JavaScript资源引用放到HTML文件底部（防止JS的加载和解析执行阻塞页面渲染）</li><li>不要在HTML中直接缩放图片（直接缩放会导致页面的重排重绘）</li><li>减少DOM元素数量和深度（减少DOM解析和绘制时长）</li><li>尽量避免使用table、iframe等慢元素（有些元素影响页面性能）</li><li>避免运行耗时的JavaScript（任何与页面初次渲染无关的逻辑功能都应延迟加载执行）</li><li>避免使用CSS表达式或CSS滤镜（CSS表达式和滤镜的解析渲染速度比较慢）</li></ul></li></ul><h4 id="移动端浏览器前端优化策略"><a href="#移动端浏览器前端优化策略" class="headerlink" title="移动端浏览器前端优化策略"></a>移动端浏览器前端优化策略</h4><ul><li><strong>网络加载类</strong><ul><li>首屏数据请求提前，避免JavaScript文件加载后才请求数据</li><li>首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化</li><li>模块化资源并行下载</li><li>将首屏必备的css和JavaScript内联到页面中避免白屏</li><li>设置文件资源的DNS预解析，让浏览器提前解析获取静态资源的主机IP</li><li>首屏完成加载后，可能会被使用的资源需要进行预加载</li><li>合理利用MTU（最大传输单元）策略，尽量保证页面HTML内容在1KB以内</li></ul></li><li><strong>缓存类</strong><ul><li>合理利用浏览器缓存，保证静态资源内容的快速加载</li><li>移动端或Hybrid应用可设置离线文件或离线包机制，加快资源载入速度，并实现离线更新</li><li>尝试使用AMP Component中的元素来代替原始的页面元素进行直接渲染</li></ul></li><li><strong>图片类</strong><ul><li>通常要保证页面中所有图片都进行压缩优化处理</li><li>使用较小图片，合理使用base64内嵌图片</li><li>使用更高压缩比格式图片，如webp等</li><li>页面图片资源推荐使用懒加载</li><li>使用media query或srcset根据不同屏幕加载不同大小图片</li><li>使用iconfont代替图片图标，iconfont体积小、矢量、易修改</li><li>一般建议单张图片不超过30k</li></ul></li><li><strong>脚本类</strong><ul><li>尽量使用ID选择器，速度快</li><li>对于需要重复使用的DOM对象，要优先设置缓存变量</li><li>页面元素尽量使用事件代理，避免直接事件绑定</li><li>在没有实现滚动处理的情况下，推荐使用touchstart代替click事件，加快点击响应速度</li><li>对touchmove、scroll这类可能连续触发回调的事件设置节流</li><li>避免使用eval、with，使用join代替连接符+，推荐使用ES6的字符串模板</li><li>尽量使用ES6+的特性来编程，更加安全高效</li></ul></li><li><strong>渲染类</strong><ul><li>设置viewport加速渲染，同时也避免了缩放导致的重排重绘</li><li>避免各种形式的重排重绘，如图片大小、位置的变化等</li><li>使用CSS 3动画，开启GPU加速</li><li>选择合适、高效的方式实现动画，尽量避免定时器等方式直接处理连续动画</li><li>部分情况下考虑使用SVG代替图片实现动画，内容小且SVG DOM结构易调整</li><li>布局渲染阶段float元素布局计算比较耗性能，推荐使用固定布局或flex布局</li><li>不滥用web字体或过多font-size声明</li></ul></li><li><strong>架构协议类</strong><ul><li>可尝试使用SPDY和HTTP 2协议</li><li>可尝试使用后端数据渲染</li><li>可尝试使用Native Viewd MNV*开发模式来避免HTML DOM性能慢的问题</li></ul></li></ul><h3 id="前端用户数据分析"><a href="#前端用户数据分析" class="headerlink" title="前端用户数据分析"></a>前端用户数据分析</h3><ul><li><strong>用户访问统计</strong><ul><li>PV：Page View，在一天内页面被所有用户访问的总次数，每一次页面刷新就增加一次PV</li><li>UV：Unique Visitor，在一天内访问内页的不同用户数，较多站点按照IP数计算</li><li>VV：Visit View，通常用户从进入网站到最终离开该网站的整个过程算一次VV</li></ul></li><li><strong>用户行为分析</strong><ul><li>页面点击量：统计用户对页面某个可点击或可操作区域的点击或操作次数</li><li>用户点击流分析：统计用户在页面中发生点击或操作动作的顺序</li><li>用户访问路径分析：统计用户访问不同页面的路径顺序</li><li>用户点击热力图：统计用户的点击或操作发生在整个页面哪些区域位置，并绘制出热力图</li><li>用户转化率：= 通过该页面注册的用户数 / 页面PV</li><li>导流转化率：= 通过源页面导入的页面访问PV / 源页面PV</li><li>用户访问时长、内容分析：统计分析用户在某些关键内容页面的停留时间</li></ul></li><li><strong>前端日志上报</strong><ul><li>通过try…catch和window.onerror两种机制获取用户页面的脚本错误信息</li><li>通过创建HTTP请求将错误信息发送到日志收集服务器</li><li>通常会建立一个简单的内容管理系统来管理查看错误日志</li><li>若要进一步完善检测异常信息，可尝试对静态资源文件加载失败的情况进行监控</li><li>可以将页面性能数据进行上报统计，来评判具体页面的性能情况</li></ul></li></ul><h3 id="前端搜索引擎优化（SEO）"><a href="#前端搜索引擎优化（SEO）" class="headerlink" title="前端搜索引擎优化（SEO）"></a>前端搜索引擎优化（SEO）</h3><ul><li>合理设置<title>、<meta keywords>、<meta description></title></li><li>使用具有语义化的HTML5标签结构，建议每个页面都有个唯一的H1标题，img标签设置alt属性</li><li>URL规范化：统一网站的地址链接、URL变化后使旧地址301指向新地址、带参数页面<head><meta name="generator" content="Hexo 3.9.0">加上canonical声明</head></li><li>用robots.txt指导搜索引擎爬虫的抓取</li><li>用sitemap文件列出网站所有URL地址来指导搜索引擎抓取</li></ul><h3 id="前端协作"><a href="#前端协作" class="headerlink" title="前端协作"></a>前端协作</h3><ul><li>与产品经理的沟通：明确产品经理提出的需求、对需求开发的难度进行评估、分析需求性价比、需求不合理时要提出质疑、做好风险管理</li><li>与后端的合作：需求开发前定好数据协议文档、采用合适的开发沟通方式</li></ul><h2 id="前端跨栈技术"><a href="#前端跨栈技术" class="headerlink" title="前端跨栈技术"></a>前端跨栈技术</h2><h3 id="JavaScript跨后端实现技术"><a href="#JavaScript跨后端实现技术" class="headerlink" title="JavaScript跨后端实现技术"></a>JavaScript跨后端实现技术</h3><ul><li><strong>Node开发</strong><ul><li><strong>Node优点</strong>：基于事件驱动和无阻塞的服务器，适合处理并发请求，尽管目前node服务器仍是单进程运行。且node端运行的是JavaScript，对于前端开发者来说学习成本低。</li><li><strong>node后端开发需要掌握的基础知识和技术</strong>：服务器知识基础、数据库知识基础、后端MVC设计理念、后端异步编程（如对数据库操作或网络请求的异步处理）、模块化思想、中间件技术、接口设计规范、后端部署技术和基本运维能力</li><li><strong>早期MEAN技术组合方案</strong>：M-MySQL、E-Express、A-angular、N-node</li><li><strong>node可解决的前后端分离模式下的问题</strong>：node可以在页面请求时直接将内容渲染到页面上输出，即直出，可解决在SPA或前后端分离模式下SEO和前端渲染展示缓慢的问题。</li></ul></li><li><strong>前后端同构</strong><ul><li><strong>前后端同构的宗旨</strong>：可以使用同一套项目代码在前后端分别进行数据渲染解析。</li><li><strong>同构的三种思路</strong>：数据模块的前端渲染和后台直出、MVVM的前端实现和和后台直出、Virtual DOM的前端渲染和后台直出</li><li><strong>需要关注的问题</strong>：前后端框架选择、模板渲染机制、构建打包、区分渲染和直出的方式</li></ul></li></ul><h3 id="跨终端设计与实现"><a href="#跨终端设计与实现" class="headerlink" title="跨终端设计与实现"></a>跨终端设计与实现</h3><h4 id="native、web、hybrid三者的区别"><a href="#native、web、hybrid三者的区别" class="headerlink" title="native、web、hybrid三者的区别"></a>native、web、hybrid三者的区别</h4><p><strong>native应用特点</strong></p><ul><li>优点<ul><li>原生系统Native API的支持，如访问本地资源、相机API等</li><li>资源在打包安装时完成，节省用户使用时的流量</li><li>可针对不同平台特性进行用户体验优化</li><li>运行速度快、性能好，可使用原生Native动画库</li></ul></li><li>缺点<ul><li>开发成本高，兼容性差，尤其Android机型</li><li>维护成本高，用户必须手动下载更新，历史版本也需要维护</li><li>上线时间不确定，一般需要通过应用商店的审核</li><li>版本更新慢，更新时需要用户重新下载安装包</li><li>应用界面的内容不可被搜索引擎检索</li></ul></li></ul><p><strong>web应用特点</strong></p><ul><li>优点<ul><li>开发成本低，使用前端开发技术即可</li><li>跨平台和终端，基于浏览器或WebView运行</li><li>部署方式简单、快捷，无需用户安装</li><li>用户总能访问到最新版本，迭代速度快</li><li>内容可被搜索引擎检索</li></ul></li><li>缺点<ul><li>浏览体验无法超越Native应用</li><li>消息推送、动画等实现方式相对Native实现方式较差</li><li>不能调用设备的原生特性，如无法访问本地资源、相机API等</li></ul></li></ul><p><strong>Hybrid应用特点</strong></p><ul><li>优点<ul><li>开发成本较低，可以使用前端开发技术，甚至可以自动添加Native外壳来实现独立移动端应用</li><li>跨平台和终端，内容网页可基于浏览器或WebView运行</li><li>拥有与Web应用相同的快速迭代特性</li><li>部署方式简单、快捷，只更新Web资源即可</li><li>可支持实现离线应用</li><li>可通过JSBridge调用设备的系统级API，如访问本地资源、相机API等</li><li>原生应用版本迭代和Web功能迭代互相独立也可以相互结合</li><li>不同性能需求的功能可以选择性使用Native或Web实现</li><li>内容可被搜索引擎检索</li><li>借助于MNV*的开发模式可以更接近Native应用的用户体验</li></ul></li><li>缺点<ul><li>部分机型兼容相对Native较差，但比Web应用体验好很多</li></ul></li></ul><h4 id="Hybrid实现方式"><a href="#Hybrid实现方式" class="headerlink" title="Hybrid实现方式"></a>Hybrid实现方式</h4><p>目前Hybrid应用的开发模式已经突破了开发效率和性能的两大问题，更加适应移动互联网时代产品高迭代速度的需求，而且目前主流的移动端应用均是采用Hybrid的方式来实现。</p><ul><li>以前端为主的Hybrid实现方式<ul><li>以完全的前端模式来开发整个应用，页面开发完成后，通过工具自动打包将前端资源目录装入Native容器中运行。打开应用运行时，除了部分通用的简单逻辑外，内部逻辑全部由打包的Web端代码来实现。</li><li>优点：前端开发者可以独立快速构建Hybrid应用，不需要Native开发人员的支持调用Native可以使用开源的JSBridge库来实现。</li><li>缺点：Native功能只能通过Web的方式实现，且无法添加复杂的Native功能；即时通信或服务器端推送的应用场景，使用web的方式实现性能较差；与Native的交互方式上也会受到固有开源库实现的限制，无法灵活拓展；无法避免在应用版本更新时重新下载安装应用的问题；Webview的执行性能较差，不适合复杂场景。</li><li>适用于中小型需要快速完成开发的应用场景。</li></ul></li><li>Native和Web结合的Hybrid实现方式<ul><li>移动端应用中Native和Web功能上的结合开发实现</li><li>Native用来实现移动端应用的通用导航菜单、系统UI层、核心界面动效、默认访问页、高效的消息推送或APP大版本的应用更新等，因为这些功能比较稳定，不涉及需要快速迭代的业务逻辑。</li><li>Web端用来实现开发迭代速度更快的相关业务层界面逻辑，如某个Native应用内关联的某个Web轻应用。</li></ul></li></ul><h4 id="基于localStorage的资源离线和更新技术"><a href="#基于localStorage的资源离线和更新技术" class="headerlink" title="基于localStorage的资源离线和更新技术"></a>基于localStorage的资源离线和更新技术</h4><p>在Hybrid应用开发时，常常需要在离线的情况下打开页面或为了让Hybrid页面应用加载启动更快，避免长时间等待资源加载过程中造成页面空白的出现。使用资源的离线缓存技术能加快页面启动时的载入速度。</p><ul><li><strong>ServiceWorker的资源离线与更新</strong>：目前兼容性很差，暂不考虑</li><li><strong>localStorage资源离线缓存与更新</strong>：将JavaScript、CSS文件缓存到localStorage，根据版本号判断是否读取本地缓存资源。</li><li><strong>基于增量文件的更新方式</strong>：通过比较不同版本就可以只加载不同版本的增量文件，但同时需要在服务器端每次新版本发布时维护多个增量文件来适应不同的旧版本更新的需要。<ul><li><strong>基于文件代码分块的增量更新机制</strong>：基于文件内容分块chunk算法进行增量更新，节省资源的量取决于块的大小和内容变化的块序号分布。</li><li><strong>基于编辑距离的增量更新机制</strong>：计算获取两个文件对比变化时每个字符的操作步骤，将操作步骤作为增量文件下载，在浏览器端进行代码的运算更新。</li></ul></li></ul><h4 id="Native与Web结合的Hybrid资源离线和更新技术"><a href="#Native与Web结合的Hybrid资源离线和更新技术" class="headerlink" title="Native与Web结合的Hybrid资源离线和更新技术"></a>Native与Web结合的Hybrid资源离线和更新技术</h4><ul><li>通常Native应用启动时会主动拉取线上web离线包版本，然后与本地保存的版本进行对比，如果没有更新则不做操作。</li><li>如果本地离线包需要更新或本地没有离线包在，则会去离线包服务器拉取最新的离线包或者拉取增量离线包到本地，然后解压合并到本地的指定离线包目录下。</li><li>当有用户访问目标页面时，Native应用会先检查该文件地址映射到的离线包本地目录中的文件。<ul><li>如果有内容则直接读取并加载；</li><li>否则线上拉取静态资源到页面上执行解析；</li><li>同时通知Native应用去拉取最新的离线包资源，这样当下次请求目标页面时Webview就可以读取到本地离线目录中的内容了。</li></ul></li><li>增量包的计算方法与localStorage的增量文件计算方法类似，如何根据两个离线包计算增量包的算法也和计算差量文件的算法类似。</li></ul><h4 id="资源覆盖率统计"><a href="#资源覆盖率统计" class="headerlink" title="资源覆盖率统计"></a>资源覆盖率统计</h4><ul><li>在增量包生成过程中，如果某个旧版本的用户使用率很小或接近0，就可以考虑后面不再对这个版本生成增量包，并让这部分用户直接拉取最近的全量包，避免在版本发布较多时线上有过多的历史增量包版本存在。</li><li>统计方法：后台统计上报版本号，每次PV统计时带上版本号。</li></ul><h4 id="Hybrid开发时需要考虑的其他问题"><a href="#Hybrid开发时需要考虑的其他问题" class="headerlink" title="Hybrid开发时需要考虑的其他问题"></a>Hybrid开发时需要考虑的其他问题</h4><ul><li>Hybrid性能问题：Hybrid的WebView存在HTML的DOM渲染和操作较慢的性能问题。可尝试调用Native原生控件来弥补这一劣势。</li><li>前端技术栈的其他应用实现：如Native编译技术、桌面应用开发</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript设计模式与开发实践》笔记</title>
      <link href="/2019/01/11/book-patterns/"/>
      <url>/2019/01/11/book-patterns/</url>
      
        <content type="html"><![CDATA[<p>本文是我阅读<a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》</a>过程中记录下来的笔记。之前以为设计模式是要到架构师那个境界才能真正用到的，看了这本书才发现，原来我们平时就一直在接触设计模式，自己也在无意识地用到了这些设计模式。理解了这些设计模式后，对日后的编码思路和代码优化也有很大的帮助，其中<a href="/2019/01/11/design-patterns/#原型模式">原型模式</a>、<a href="/2019/01/11/design-patterns/#策略模式">策略模式</a>、<a href="/2019/01/11/design-patterns/#发布-订阅模式（观察者模式）">发布-订阅模式</a>给我的印象是最深刻的。</p><a id="more"></a><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li>JavaScript是一门基于原型的面向对象语言，它的对象系统是使用原型模式搭建的，没有类的概念，将函数作为一等对象。</li><li>很多设计模式都是通过闭包和高阶函数实现的；编写函数式语言风格的代码，离不开call和apply。</li><li>所有设计模式的实现都遵循一条原则：找出程序中变化的部分，并将变化封装起来，注重提高可复用和可维护性，保证代码的高内聚低耦合。</li><li>很多模式的类图和结构看起来几乎没有区别，例如代理模式和装饰者模式、策略模式和智能命令模式等。虽然看起来差不多，但是它们之间的意图和设计目的是不同的。</li><li>我们不能刻意的去套用设计模式，而是在理解了那些优秀的设计模式后，很自然地将那些模式融入到代码中。</li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li><strong>设计模式</strong>：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。</li><li><strong>动态类型语言</strong>：单至类型上的定义，变量类型在运行时才会确定。</li><li><strong>面向对象编程(OOP)</strong>：本质是以建立模型体现出来的抽象思维过程和面向对象的方法。以类为中心，抽象、封装、继承和多态是面向对象的基础。</li><li><strong>抽象</strong>：提取现实世界中某事物的关键特性，为该事物构建模型的过程。得到的抽象模型(包含属性、操作)称之为类。</li><li><strong>封装</strong>：使类具有独立性和隔离性，保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。</li><li><strong>继承</strong>：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。</li><li><strong>多态</strong>：同一操作作用于不同对象上，可产生不同的解释和不同的执行结果。通常使用继承来得到多态效果。</li><li><strong>鸭子类型</strong>：只关注对象行为，不关注对象本身。</li><li><strong>单一职责原则(SRP)</strong>：一个对象（方法）只做一件事。（低耦合）</li><li><strong>最少知识原则(LKP)/迪米特法则</strong>：一个软件实体（类、模块、函数等）应当尽可能少地与其他实体发生相互作用。（对象之间减少交互）</li><li><strong>开放-封闭原则</strong>：软件实体应该是可以扩展的，但是不可修改。</li></ul><h3 id="this、call和apply"><a href="#this、call和apply" class="headerlink" title="this、call和apply"></a>this、call和apply</h3><ul><li>this是执行上下文环境的一个属性，而不是某个变量对象的属性，总是指向一个对象。</li><li>call和apply能很好地体现JavaScript函数式的语言特性。<ul><li>最常见的用途是改变函数内部的this指向。</li><li>apply是Function.prototype.bind的实现核心。</li><li>借用其他对象的方法，扩充函数赖以运行的作用域，可以借此实现多重继承</li></ul></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数式指至少满足下列条件之一的函数：</p><ul><li>函数可以作为参数被传递，如回调、节流、分时函数。</li><li>函数可以作为返回值输出，如柯里化(部分求值)函数</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><strong>定义</strong>：指有权访问另一个函数作用域中变量的函数。   </li><li><strong>常见方式</strong>：函数内创建内部函数，外部通过内部函数访问此函数的局部变量。  </li><li><strong>作用</strong>：<ul><li>突破作用链域，将函数内部的变量和方法传递到外部。</li><li>延续局部变量的生存周期，防止被垃圾回收机制清除。  </li></ul></li><li><strong>应用</strong>：<ul><li>将不需要暴露在全局的变量封装成“私有变量”；</li><li>缓存功能，减少重复计算或防止数据丢失；</li></ul></li></ul><h2 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a><div style="color:#a88773">创建型模式</div></h3><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><ul><li><strong>定义</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li><li><strong>要点</strong>：是一种对象创建型模式，实现关键是语言本身是否提供了clone方法。</li><li><strong>基本规则</strong>：<ul><li>所有数据都是对象。</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。</li><li>对象会记住它的原型。</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。</li></ul></li><li><strong>意义</strong>：不单是一种设计模式，也是一种编程泛型，它构成了JavaScript这门语言的根本。</li><li><strong>场景</strong>：在初始化信息不发生变化的情况，用克隆进行拷贝。</li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li><strong>定义</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 </li><li><strong>要点</strong>：将创建对象和管理单例的职责分布在两个不同的方法中。</li><li><strong>意义</strong>：惰性单例模式是重点，指的是在需要的时候才创建唯一的对象实例，非常简单实用。</li><li><strong>场景</strong>：登录浮窗、全局缓存、window对象等。</li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a><div style="color:#a88773">结构型模式</div></h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><ul><li><strong>定义</strong>：为对象提供一个代用品或占位符，以便控制对它的访问。</li><li><strong>要点</strong>：虚拟代理是最常用的，用一个类去访问原类的接口，进行额外的操作。</li><li><strong>意义</strong>：在客户看来，代理对象和本体是一致的（可通过鸭子类型来检测一致性），用户可以放心得在任何使用本体的地方替换成使用代理。</li><li><strong>场景</strong>：虚拟代理（将开销大的对象延迟到需要时再创建），如懒加载、合并请求；缓存代理（为开销大的运算结果提供临时存储）；保护代理（控制不同权限的对象对目标对象的访问）</li></ul><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><ul><li><strong>定义</strong>：用小的子对象来构建更大的对象。</li><li><strong>要点</strong>：将对象合成树形结构，以表示“部分-整体”的层次结构。</li><li><strong>意义</strong>：通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。</li><li><strong>场景</strong>：文件系统的增删改查等树形结构场景。</li></ul><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><ul><li><strong>定义</strong>：运用共享技术有效的支持大量细粒度的对象。</li><li><strong>要点</strong>：将对象属性划分为内部状态与外部状态，剥离了外部状态的对象成为共享对象，在合适的时刻将外部状态组装进共享对象。</li><li><strong>意义</strong>：用于性能优化，用时间换空间，通过共享大幅度减少单个实例的数目。</li><li><strong>场景</strong>：上次创建的DOM节点共享给下次创建操作。</li></ul><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><ul><li><strong>定义</strong>：在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责，常常会形成一条装饰链。</li><li><strong>要点</strong>：将对象放入另一个对象中，这些对象以链的形式进行引用，形成一个聚合对象。请求沿着链依次传递到所有对象，每个对象执行完自身操作，再讲请求转发给下一个对象。</li><li><strong>意义</strong>：在框架开发中非常有用，个性化功能可在框架之外动态装饰上去。</li><li><strong>场景</strong>：统计函数执行时间、插件式表单验证等。</li></ul><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><ul><li><strong>定义</strong>：将一个类的接口转换成客户希望的另外一个接口。</li><li><strong>要点</strong>：不需要改变已有接口，只包装一次。</li><li><strong>意义</strong>：复用现存的类，客户端统一调用同一接口，更简单、直接、紧凑。</li><li><strong>场景</strong>：当系统的数据和行为都正确，但接口不符时。</li></ul><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a><div style="color:#a88773">行为型模式</div></h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><ul><li><strong>定义</strong>：定义一系列算法，各自封装成策略类，对context发起请求时，context将请求委托给对应的策略类。</li><li><strong>要点</strong>：将算法的使用(环境类context)和算法的实现(策略类)分离开来。</li><li><strong>意义</strong>：策略模式是对象多态的完美体现，高阶函数就是一种隐式的策略模式。策略模式已经融入到了JS语言本身中。</li><li><strong>场景</strong>：游戏动效、验证表单等。</li></ul><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><ul><li><strong>定义</strong>：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</li><li><strong>要点</strong>：循环访问聚合对象（包括数组和类数组对象）中的各个元素，但没有规定访问规则，即可使用顺序、倒序、中序等方式。</li><li><strong>意义</strong>：将迭代的过程从业务逻辑中分离出来，不用关心对象的内部构造。绝大部分语言都内置了迭代器。</li><li><strong>场景</strong>：内部迭代器（内部已定义好迭代规则，外部不需要关心迭代器内部实现，外部仅需一次初始调用）；外部迭代器（必须显示地请求迭代下一个元素，可手动控制迭代的过程或顺序）</li></ul><h4 id="发布-订阅模式（观察者模式）"><a href="#发布-订阅模式（观察者模式）" class="headerlink" title="发布-订阅模式（观察者模式）"></a>发布-订阅模式（观察者模式）</h4><ul><li><strong>定义</strong>：当一个对象的状态发生变化时，所有依赖于它的对象都将得到通知。</li><li><strong>要点</strong>：在JS中是用注册回调函数的形式来代替传统的发布订阅者模式。</li><li><strong>意义</strong>：发布订阅者模式可以实现对时间及对象间的解耦。从架构上看，MVC和MVVM都少不了发布订阅者模式，而且JS本身也是一门基于事件驱动的语言。</li><li><strong>场景</strong>：DOM节点上绑定事件函数；订阅ajax请求的error、succ等事件；模块之间的通信；</li></ul><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><ul><li><strong>定义</strong>：将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及执行可撤销的操作。</li><li><strong>要点</strong>：客户(client)创建命令；调用者(invoking)执行该命令；接收者(receiving)在命令执行时执行相应操作。当命令对象可以直接实现请求时，就不再需要接受者的存在，这时的命令模式与策略模式非常相近，只有意图的不同。</li><li><strong>意义</strong>：旨在将函数的调用、请求和操作封装成一个单一的对象；解耦调用者与接收对象。</li><li><strong>场景</strong>：命令模式与策略模式一样融入了JS语言中。</li></ul><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><ul><li><strong>定义</strong>：子类实现中的相同部分被上移到父类，将不同部分留待子类实现。</li><li><strong>要点</strong>：在抽象父类中封装好子类的算法框架和方法的执行顺序，再由子类继承抽象类。</li><li><strong>意义</strong>：基于继承的代码复用技术。</li><li><strong>场景</strong>：有重复行为的平行子类。</li></ul><h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><ul><li><strong>定义</strong>：一系列可能会处理请求的对象被连接成一条链，请求沿着链传递，直到有对象处理为止。</li><li><strong>要点</strong>：节点数量和顺序可以自由变化，在运行时也能决定链中包含哪些节点。</li><li><strong>意义</strong>：解耦了请求的发送者和多个接收者之间的关系。</li><li><strong>场景</strong>：作用域链、原型链、DOM节点的事件冒泡。</li></ul><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><ul><li><strong>定义</strong>：用一个中介对象来封装一系列的对象交互。</li><li><strong>要点</strong>：所有相关对象之间的交互都交给中介者来实现和维护。</li><li><strong>意义</strong>：解除对象与对象之间的紧耦合关系。</li><li><strong>场景</strong>：form表单各项的实时校验。</li></ul><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><ul><li><strong>定义</strong>：将对象的内部状态都封装成独立的类，请求会被委托给当前的状态对象。</li><li><strong>要点</strong>：不同状态下，对象像是从不同的类中实例化而来的。</li><li><strong>意义</strong>：状态模式是状态机的实现之一。</li><li><strong>场景</strong>：游戏人物状态切换等。</li></ul><h2 id="代码重构技巧"><a href="#代码重构技巧" class="headerlink" title="代码重构技巧"></a>代码重构技巧</h2><ol><li>提炼函数，包括重复代码、条件分支语句等情况</li><li>合理使用循环</li><li>使用return提前让函数退出</li><li>传递对象参数代替过程的参数列表</li><li>尽量减少参数数量</li><li>少用三目运算符（可读性差）</li><li>合理使用链式调用</li><li>分解大类型</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见51</title>
      <link href="/2018/11/10/goodbye51/"/>
      <url>/2018/11/10/goodbye51/</url>
      
        <content type="html"><![CDATA[<p><strong>51信用卡</strong>是我入职的第一家公司，前端开发也是我的第一份工作。从2017年6月开始实习算起，也在公司待了一年多，在很多同事眼中也是个老员工了。这一年多来我也是见证了公司的起起伏伏，从飞速扩张到上市到人员结构优化，感想真的太多了。<br><a id="more"></a></p><p>我见到了很多套路，也学到了很多反套路；待过很简单很轻松的项目组，也待过很累很难的项目组；见过同事们一起谈笑风生，也见过因为一些矛盾而大吵三天的场面。幸好研发部门还都是比较单纯的一群人，心机还不算多，对我这种小绵羊性格的还算友善。从校园到社会都感觉不到过渡，完全是两个世界，我知道我现在体会到的只是冰山一角，所以我还要努力让自己变得成熟、强大。正所谓好记性不如烂笔头，打算把这些重要的东西抓紧记下来。</p><p><br></p><h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><ul><li><strong>2017-06-15 ：入职51实习，进入金融组</strong></li><li>2017-06-20 ：进入案件管理系统项目组</li><li><strong>2017-07-24 ：金融组分离，转至后台组</strong>  </li><li>2017-08-10 ：进入工程平台业务线（陀飞轮、NX-SERVICE）</li><li><strong>2017-11-30 ：实习生转为校招生</strong></li><li><strong>2018-03-05 ：后台组分离，转至后台业务组。</strong><ul><li>离开工程平台业务线（陀飞轮、NX-SERVICE）</li><li>离开案件管理系统项目组；</li><li>加入后台业务组，进入运营业务线（顶天、金融渠道）。 </li></ul></li><li><strong>2018-07-01 ：毕业，签订劳动合同生效。</strong></li><li>2018-08-16 ：进入享读创新项目。</li><li><strong>2018-08-21 ：前端组织架构大调整，转至产品运营业务组，工作项目不变。</strong></li><li><strong>2018-10-26 ：离职</strong></li></ul><p><br></p><h2 id="点滴感悟"><a href="#点滴感悟" class="headerlink" title="点滴感悟"></a>点滴感悟</h2><ul><li>做什么事都要趁早，不能一拖再拖，改掉拖延症。</li><li>业务压力大时要学会调剂自己，同时也要去尝试沟通；</li><li>不能光埋头做业务，要抽时间去提升、拓展自己的能力；</li><li>记笔记、写博客、写文档是个好习惯，要坚持下去；</li><li>要学会去管理时间，多做规划，不能节奏一团糟；</li><li>谨言慎行，质问他人前先自己思考、向前辈请教。</li><li>多和前辈聊天、谈心，不能自己闷着钻牛角尖。</li><li>要时刻有危机感，想办法把自己提升到不可替代的位置。</li><li>要多去思考怎么样去提升自己来改变现状，而不是一味要求别人来改变；</li><li>要多去关注组内的发展建设，看到组内存在的问题要积极想办法去解决；</li><li>在团队中，一定要要重视代码规范，要统一；</li><li>每个系统都有价值，对待每个系统都要带有责任心、摆正心态；</li><li>要沉浸到项目中，提出自己的见解，面向用户编程，而不是面向需求编程；</li><li>任何事都要通知到位，要多和团队沟通；</li><li>多去换位思考，站在不同角度去分析项目、产品、工作、团队及公司决策；</li></ul><p><br></p><h2 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h2><h3 id="团队工作"><a href="#团队工作" class="headerlink" title="团队工作"></a>团队工作</h3><ul><li>加入后台组组委会，协助组内推动代码规范，组织codeReview，管理组内财务，维护组内wiki。</li><li>加入性能优化专题小组，研究并整理理论层面、代码层面及典型场景下的优化方案。</li><li>辅助、指导非前端开发人员学习并构建前端项目，与其他技术组互相学习，并产出文档：<ul><li>2018-06-01 ~ 2018-07-13：指导并协助基础测试组测开人员开发NBTms项目(自动化测试平台)。</li><li>2018-05-28 ~ 2018-10-26：指导并协助后台运营组后端人员开发票券后台系统。</li></ul></li></ul><hr><h3 id="案件管理系统"><a href="#案件管理系统" class="headerlink" title="案件管理系统"></a>案件管理系统</h3><p>时间：2017-06-20 ~ 2018-01-10</p><h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h4><p>公司内部后台系统。系统分为订单列表、案件来源、案件管理、名单库、调查监控四个大模块，每个模块包含了若干页面。反欺诈业务人员能集中查看各类详细数据，快速查出高风险订单与重要案件，利用标签、收藏夹、统计等功能高效整理数据，同时，不同角色操作权限的严格控制保证了反欺诈业务的规范性。</p><h4 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>2017-06-20 ~ 2017-07-11：中途接手，独立完成两期需求。由于是老项目，前后端不分离，使用jQuery+bootstrap。</li><li>2017-07-12 ~ 2018-01-10：独立完成项目整体的重构，并完成后续的三期大版本迭代工作。使用vue + vuex + webpack + less + <a href="https://51nb.github.io/miox-doc/" target="_blank" rel="noopener">miox(公司内部)</a> + 内部组件库。</li><li>2018-03-05：由于组织架构调整，交由其他组维护。</li></ul><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>独立开发、中途接手、完成重构。</li><li>角色分配、权限控制功能较为复杂。</li><li>对重要信息展示方式方面要求较高。</li><li>技术栈：vue + vuex + webpack + less + <a href="https://51nb.github.io/miox-doc/" target="_blank" rel="noopener">miox(公司内部)</a> + 内部组件库。</li></ul><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h4><p>这是我的启蒙项目。这是我入职以来接触的第一个项目，先是在学长的带领下维护老系统，不久就开始对其进行整体重构工作。期间我经历了完整的项目流程，接触到了公司的各种优秀框架，这些对于我来说是一种全新的体验。学长也是很耐心的教我使用各种工具、框架，带我接触项目，也日常检查我的代码，指出可以优化的地方，教我如何自主学习，养成良好的开发习惯，提高各方面的能力。在学长及后端大哥的帮助下，很快适应了，沟通能力和代码能力得到了飞速的提升，并如期完成了项目。完成了一个月的重构工作后，我也算是走出了新手村。在不断的请教和学习下，我对公司的前端体系有了基本的了解，对后台模板代码有了较深的理解，对项目管理也有了大体的认知。</p><hr><h3 id="数据研发平台"><a href="#数据研发平台" class="headerlink" title="数据研发平台"></a>数据研发平台</h3><p>时间：2017-08-10 ~ 2018-03-03</p><h4 id="项目介绍-1"><a href="#项目介绍-1" class="headerlink" title="项目介绍"></a>项目介绍</h4><p>公司内部工程平台相关系统。数据研发平台是结合公司的实际应用场景自研的一个集中式的任务调度系统。具备调度、即席查询、数据导入导出、权限与容量管理、流式计算、监控与报警等功能。它能解放平台开发、平台运维的精力，并解决用户的以下痛点：1、化繁为简，减少配置；2、自动化IDE，方便开发调试；3、版本化的任务管理；4、统一任务和数据的视图；5.资源报表与统计；6、支持多种任务类型。</p><h4 id="工作内容-1"><a href="#工作内容-1" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>2017-08-10 ~ 2017.09.22：独立开发完成第一个简单版本，实现一些基本功能。</li><li>2017-10-10 ~ 2018-03-03：与另外两个搭档合作开发完成整个系统。我主要负责各类任务的可视化管理、各类任务调度配置、任务依赖关系管理等功能。</li><li>2017-12-22 ~ 2018-03-03：在数据研发平台被完全替代前，独立维护数据研发平台的前身-Tourbillon，配合数据研发平台的上线进行修改及维护。</li><li>2018-03-03：由于组织架构调整，交由其他组维护。</li></ul><h4 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h4><ul><li>协作开发，新启项目。</li><li>对于数据的可视化程度要求较高。</li><li>项目规模很大，对团队协作能力要求较高。</li><li>任务比较繁重，对个人抗压能力要求较高。</li><li>技术栈：vue + vuex + webpack + less + element UI + codemirror + echarts + vis.js + miox + 内部组件库。</li></ul><h4 id="感悟-1"><a href="#感悟-1" class="headerlink" title="感悟"></a>感悟</h4><p>这是我接手的第二个项目，比案件管理系统要复杂得多，并且不像案件管理系统已经趋于稳定了，它需要我从无到有的开始开发、磨合，是对我的一个很大的考验。这需要我考虑到很多东西，与产品、后端探讨项目设计中的各种问题。这也我是第一次与其他同事协同开发整个前端，第一次进项目会议室体验封闭式开发，为了各种bug焦头烂额，为了赶进度加班加点。由于代码非常复杂，又是协作开发，对代码质量及规范、团队合作、项目沟通、时间管理等方面有了更深刻的感悟。也学到了不少黑科技，收货颇丰。</p><hr><h3 id="NX-SERVICE"><a href="#NX-SERVICE" class="headerlink" title="NX-SERVICE"></a>NX-SERVICE</h3><p>时间：2017-11-20 ~ 2018-03-03</p><h4 id="项目介绍-2"><a href="#项目介绍-2" class="headerlink" title="项目介绍"></a>项目介绍</h4><p>公司内部工程平台相关系统。NX-SERVICE是工程平台部整个部门统一数据接口服务平台，用户可以进行检索、接口权限申请、接口配置及接口测试等。对于用户来说，此系统可以通过配置化的方式自动生成数据调用接口来减少新增接口的开发工作量，还可以保障业务方数据调用的稳定性，降低维护成本；对于平台来说，NX-SERVICE的数据仓库模型和计算服务的能力输出，可以完善整个数据服务链路的闭环，也便于做好数据出口的权限控制。</p><h4 id="工作内容-2"><a href="#工作内容-2" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>2017-11-20 ~ 2017-12-07：独立完成第一个大版本。</li><li>2018-03-03：由于组织架构调整，交由其他组维护。</li></ul><h4 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h4><ul><li>独立开发，新启项目。</li><li>后端第一次接触web开发，需要我去配合与协助纠正。</li><li>技术栈：vue + vuex + webpack + less + codemirror + miox + 内部组件库。</li></ul><h4 id="感悟-2"><a href="#感悟-2" class="headerlink" title="感悟"></a>感悟</h4><p>经过在数据研发平台项目组中一段时间的总结沉淀，我懂得了如何去加强沟通，代码方面要注重可复用性、可维护性与规范性。由于后端刚接触web开发，所以在共同钻研的过程中，我对于前后端合作也是有了更多感受与想法，很多踩到的坑都是宝贵的经验。这个项目算是对我的一个考核，考核我在之前的项目锻炼中，能力到底有没有真正的产生质的飞跃，总结出来的经验能不能真正的用到实际场景中。最后项目顺利上线，我对自己的努力结果还是挺满意的。</p><hr><h3 id="金融渠道管理后台"><a href="#金融渠道管理后台" class="headerlink" title="金融渠道管理后台"></a>金融渠道管理后台</h3><p>时间：2018-03-08 ~ 2018-10-26</p><h4 id="项目介绍-3"><a href="#项目介绍-3" class="headerlink" title="项目介绍"></a>项目介绍</h4><p>对内也对外的系统。外部渠道方只能查看有权限的数据，内部人员则可以利用本系统来管理所有渠道、查看各渠道报表数据、计算结算金额及给外部渠道方设置权限。业务人员可以直观得看到渠道效果，帮助他们分析数据，思考出最大利益的投放方案，来提高拉新、增加转化率。</p><h4 id="工作内容-3"><a href="#工作内容-3" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>2018-03-08 ~ 2018-10-26 ：中途接手，独立完成所有大小需求。</li><li>2018-07-24 ~ 2018-09-23 ：项目整体大优化，解决性能瓶颈。</li></ul><h4 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h4><ul><li>独立开发，中途接手，完成重构。</li><li>项目接手后，发现了许多历史遗留bug及可优化点，由于耦合性过强，整改任务还是比较艰巨的。</li><li>技术栈：vue + vuex + webpack + less + vue-router + element UI + 内部组件库。</li></ul><h4 id="感悟-3"><a href="#感悟-3" class="headerlink" title="感悟"></a>感悟</h4><p>这个项目接手后，发现了许多问题及可优化点：由于组件库混用导致本地调试控制台出现了大量报错、某些依赖包版本过低兼容性差、大量代码严重冗余、复用性差、耦合性过强、可扩展性差、没有遵守组内统一规范等等。整体优化改动很大，相当于是重构，需求又一直在迭代，需要经过严谨的测试才能发布上线，而且项目人员又少，缺少产品和测试。尽管整改难度大，但我仍坚持接受这个挑战，抽出空余时间理解整个项目，与业务方沟通说明优化方案，一点点修改整个框架，抽出通用组件，重写逻辑杂乱的页面，同时向专业测试人员请教以完成高质量自测。优化版上线后，性能提升不少，还增加了一些实用小功能，后续开发工作也省了不少时间，结果还是非常满意的，业务方也是赞赏不已，所谓磨刀不误砍柴工嘛。</p><hr><h3 id="顶天系统"><a href="#顶天系统" class="headerlink" title="顶天系统"></a>顶天系统</h3><p>时间：2018-03-09 ~ 2018-10-26</p><h4 id="项目介绍-4"><a href="#项目介绍-4" class="headerlink" title="项目介绍"></a>项目介绍</h4><p>公司内部运营后台系统。集成了渠道素材管理、投放管理、渠道对接管理、应用信息管理、应用包管理(上传apk文件,补丁管理)、渠道费用管理、渠道媒体管理及X项目配置管理等功能模块，能满足营销部门及运营线开发的很多需求。</p><h4 id="工作内容-4"><a href="#工作内容-4" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>2018-03-09 ~ 2018-10-26 ：中途接手，对已有功能进行迭代维护。</li><li>2018-06-14 ~ 2018-10-26 ：重建素材库，改造成类似网盘的模式，并进行迭代维护。</li><li>2018-03-09 ~ 2018-05-28 ：开发补丁包管理模块，并进行迭代维护。</li></ul><h4 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h4><ul><li>独立开发，中途接手。</li><li>技术栈：vue + vuex + webpack + less + vue-router + element UI。</li></ul><h4 id="感悟-4"><a href="#感悟-4" class="headerlink" title="感悟"></a>感悟</h4><p>顶天是一个比较简单的项目，页面功能简单，逻辑清晰易懂，也许是因为我有经验了吧。很开心的是认识了一个非常优秀的后端，前后端分工很明确，每次需求接口完成都很快，并且都会在wiki上写出一份很详细的接口使用文档，做事也会考虑到很深很远，和他合作效率超高，也从他身上学到了不少品质。</p><hr><h3 id="享读reRead"><a href="#享读reRead" class="headerlink" title="享读reRead"></a>享读reRead</h3><p>时间：2018-08-16 ~ 2018-10-26</p><h4 id="项目介绍-5"><a href="#项目介绍-5" class="headerlink" title="项目介绍"></a>项目介绍</h4><p>公司对外创新项目。享读是一款稍后阅读工具，支持多平台文章收藏与存储。在提供极致阅读体验的同时，你还可以在圈子中阅读朋友收集的优质内容，相互碰撞，得到启发。同时支持知乎、微信公众号、今日头条、豆瓣等全网主流平台文章的收藏与内容的优化排版。</p><h4 id="工作内容-5"><a href="#工作内容-5" class="headerlink" title="工作内容"></a>工作内容</h4><ul><li>相关H5页面：包括<a href="https://reread.com.cn/#/" target="_blank" rel="noopener">官网</a>、文章详情页、个人收藏页、部分壳内页面。</li><li>微信小程序：本项目小程序主要做导流用，具备享读基本的分享、阅读功能，包括个人圈子列表页、圈子详情页、圈子成员页、文章详情页。</li><li>后台系统：开发并维护两个享读后台系统——享读运营后台、享读文章解析后台。</li><li>爬虫工作：承担一部分简单爬虫工作，同时辅助优化一些较复杂的爬取脚本。</li><li>Chrome插件：开发在Chrome上可同步、收藏文章的享读插件。</li></ul><h4 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h4><ul><li>独立开发、新启项目、公司创新项目</li><li>H5技术栈：vue + vuex + webpack + sass + vue-router + 内部组件库</li><li>后台系统技术栈：vue + vuex + webpack + less + vue-router + 内部组件库</li><li>微信小程序技术栈：mpvue + vuex + webpack + less</li><li>爬虫技术栈：node + puppetter</li><li>chrome插件技术栈：vue + vuex + webpack + sass + element UI</li></ul><h4 id="感悟-5"><a href="#感悟-5" class="headerlink" title="感悟"></a>感悟</h4><p>由于工作长期都是后台系统，所以我的移动端开发能力是比较薄弱的。幸运的是我又进入了享读项目组，涉及到了小程序、H5、chrome插件甚至爬虫，带我正式进入了移动端的领域。经过这段时间的努力以及各位同事的帮助，终于对移动端的开发有所积累，努力完成了从pc端到移动端的过渡，补全自己在移动端开发方面能力的不足。在这个创新项目组中，虽然一直都在为用户体系、微信审核等忙得焦头烂额，找公司各种人沟通打交道，但是每天都过得很充实，一步一步踩的坑都是非常宝贵的经验。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>puppeteer实战-微信文章爬取调研</title>
      <link href="/2018/10/20/node-puppeteerWX/"/>
      <url>/2018/10/20/node-puppeteerWX/</url>
      
        <content type="html"><![CDATA[<h2 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h2><p>Puppeteer是一个Nodejs的库，支持调用Chrome的API来操纵Web，可以很方便的用它来抓取文章。微信公众号文章又是大家阅读量非常大的一个平台，但是想要完美得抓取出公众号文章是相当难的。<br><a id="more"></a></p><h2 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h2><p>微信公众号的文章一般是通过如下的富文本编辑器进行编辑，就算是使用了其他第三方的编辑器（如秀米），也是编辑完再复制到后台的，所以只研究后台的这个编辑器就OK了。<br><img src="/image/puppeteer/1-1-1.png" alt="编辑工具"></p><h2 id="典型文章"><a href="#典型文章" class="headerlink" title="典型文章"></a>典型文章</h2><ol><li>带视频的文章： <a href="https://mp.weixin.qq.com/s/Uw6b7_W_NkCZDIce4Obn6g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Uw6b7_W_NkCZDIce4Obn6g</a>  </li><li>带音频的文章：<a href="https://mp.weixin.qq.com/s/-5oj6Q4qYS0gf5hptNYfjw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-5oj6Q4qYS0gf5hptNYfjw</a>  </li><li>带投票的文章：<a href="https://mp.weixin.qq.com/s/ROlm_YXgmQMC1of7CEojRw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ROlm_YXgmQMC1of7CEojRw</a>  </li><li>带小程序二维码的文章：<a href="https://mp.weixin.qq.com/s/A9UvCji6XJmfusNpSWigFQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/A9UvCji6XJmfusNpSWigFQ</a>  </li><li>特殊视频类文章：<a href="https://mp.weixin.qq.com/s/XPrdTJppD-jVCwuGzdd0Ew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XPrdTJppD-jVCwuGzdd0Ew</a><br>推送出来是个视频，点进去是篇带视频的文章：<br><img src="/image/puppeteer/1-2-1.png" alt="特殊视频类文章"></li><li>分享类文章：  <ul><li><a href="https://mp.weixin.qq.com/s/fnVRpI1rvMHDnTZIiMzL-A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fnVRpI1rvMHDnTZIiMzL-A</a> </li><li><a href="https://mp.weixin.qq.com/s/nlR6AzRi1IPnWh0m9M9dcA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nlR6AzRi1IPnWh0m9M9dcA</a></li></ul></li><li>争议类文章：<ul><li><a href="https://mp.weixin.qq.com/safe/dispute?action=info&amp;__biz=MzIxMjgxMDAwOA==&amp;mid=2247485963&amp;idx=1&amp;sn=661d71f440962cebc08594abb124bd20#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/safe/dispute?action=info&amp;__biz=MzIxMjgxMDAwOA==&amp;mid=2247485963&amp;idx=1&amp;sn=661d71f440962cebc08594abb124bd20#wechat_redirect</a></li></ul></li></ol><h2 id="元素分析"><a href="#元素分析" class="headerlink" title="元素分析"></a>元素分析</h2><h3 id="普通元素"><a href="#普通元素" class="headerlink" title="普通元素"></a>普通元素</h3><ul><li>这些看起来很复杂的元素，都是富文本，可以简单理解为带css样式的图片和文字<br><img src="/image/puppeteer/1-3-1.png" alt="普通元素"></li></ul><h3 id="特殊图片元素"><a href="#特殊图片元素" class="headerlink" title="特殊图片元素"></a>特殊图片元素</h3><ul><li>右上角带着类似出口标志的都是带超链接的图片</li><li>特征：class=”js_jump_icon h5_image_link”<br><img src="/image/puppeteer/1-3-2.png" alt="特殊图片元素"></li></ul><h3 id="视频元素"><a href="#视频元素" class="headerlink" title="视频元素"></a>视频元素</h3><ul><li>特征：class=”js_tx_video_container” 嵌iframe的方式</li><li>上传视频要求：视频不能超过20M，超过20M的视频可至腾讯视频上传后添加，也可通过添加视频详情页链接以及公众号文章链接插入视频，视频时长不少于1秒，不多于10小时，支持大部分主流视频格式。</li><li>小于20MB的视频好像也会转到腾讯视频（如<a href="https://mp.weixin.qq.com/s/VOLKVAIcOqiX-XAv-s3b2w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/VOLKVAIcOqiX-XAv-s3b2w</a> 待验证）</li></ul><h3 id="音频元素"><a href="#音频元素" class="headerlink" title="音频元素"></a>音频元素</h3><ul><li>特征：qqmusic标签，class=”db qqmusic_area</li><li>上传音频要求：格式支持mp3、wma、wav、amr，文件大小不超过30M，语音时长不超过30分钟</li></ul><h3 id="投票元素"><a href="#投票元素" class="headerlink" title="投票元素"></a>投票元素</h3><ul><li>特征：class=”vote_iframe js_editor_vote_card” </li><li>嵌iframe的方式加进文章</li></ul><h3 id="小程序元素"><a href="#小程序元素" class="headerlink" title="小程序元素"></a>小程序元素</h3><ul><li>特征：mp-miniprogram标签，class=”weapp_display_element js_weapp_display_element”</li></ul><h3 id="文章链接卡片"><a href="#文章链接卡片" class="headerlink" title="文章链接卡片"></a>文章链接卡片</h3><ul><li>公众号可分享原创声明文章：<a href="https://jingyan.baidu.com/article/454316ab126339f7a7c03aae.html" target="_blank" rel="noopener">微信公众号如何分享原创声明文章？</a>，分享后网页样式会有所不同。</li><li>分享者只能编辑引导语，且只能编辑文字，并且限制在140字以内，无法插入图片，文字样式等也不可更改。</li><li>例如：<a href="https://mp.weixin.qq.com/s/fnVRpI1rvMHDnTZIiMzL-A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fnVRpI1rvMHDnTZIiMzL-A</a></li><li>特征：id=”js_share_content”</li></ul><h3 id="底部广告与留言元素"><a href="#底部广告与留言元素" class="headerlink" title="底部广告与留言元素"></a>底部广告与留言元素</h3><ul><li>pc端会隐藏掉 点赞小手 及 以下的所有内容，所以不用去管底部的广告与留言。<br><img src="/image/puppeteer/1-3-3.png" alt="底部广告与留言元素"></li></ul><h3 id="打赏元素"><a href="#打赏元素" class="headerlink" title="打赏元素"></a>打赏元素</h3><ul><li><a href="https://mp.weixin.qq.com/s/8VLIsbkuQcAFI5qM_B4g3w" target="_blank" rel="noopener">打赏功能</a>，由于微信和苹果吵了一架，iOS就没有了赞赏功能，但是PC上打开是没有的，所以也不用管了。<br><img src="/image/puppeteer/1-3-4.png" alt="打赏元素"></li></ul><h2 id="非文章内容"><a href="#非文章内容" class="headerlink" title="非文章内容"></a>非文章内容</h2><h3 id="微信自带广告"><a href="#微信自带广告" class="headerlink" title="微信自带广告"></a>微信自带广告</h3><ul><li>位于 点赞小手 下方</li><li>在PC端打开不会出现不用管。</li></ul><h3 id="评论留言及打赏"><a href="#评论留言及打赏" class="headerlink" title="评论留言及打赏"></a>评论留言及打赏</h3><ul><li>位于 点赞小手 下方</li><li>在PC端打开不会出现不用管。</li></ul><h3 id="编辑者放的广告"><a href="#编辑者放的广告" class="headerlink" title="编辑者放的广告"></a>编辑者放的广告</h3><ul><li>普通文本：如 “点击关注…”、“点击阅读原文”；</li><li>带超链接的广告图片；</li><li>不带超链接的普通广告图片；</li><li>小程序卡片；  </li></ul><p>由于那些内容是编辑者自己放的，有些情况下其本身是文章中不可删除的内容部分，若一概删除会有内容丢失的风险。</p><h3 id="文章推荐列表"><a href="#文章推荐列表" class="headerlink" title="文章推荐列表"></a>文章推荐列表</h3><ul><li>当前公众号内的往期文章</li><li>“你可能喜欢的文章”</li><li>其他合作公众号的推荐文章  </li></ul><p>由于这些列表都是编辑者自己放的，有些情况下其本身是文章中不可删除的内容部分，若一概删除会有内容丢失的风险。</p><h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><ul><li>公众号的二维码</li><li>私人号的二维码</li><li>打赏用的二维码</li><li>H5页面的二维码</li></ul><p>由于这些二维码都是编辑者自己放的，有些情况下其本身是文章中不可删除的内容部分，若一概删除会有内容丢失的风险。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="lt-head-代码"><a href="#lt-head-代码" class="headerlink" title="&lt;head>代码"></a>&lt;head>代码</h3><ul><li>document.title 获取&lt;title>&lt;/title></li><li>无网站描述</li></ul><h3 id="lt-body-代码"><a href="#lt-body-代码" class="headerlink" title="&lt;body>代码"></a>&lt;body>代码</h3><ul><li>document.getElementById(“activity-name”) 获取 id=”activity-name” 为标题 （分享类文章没有标题）</li><li>document.getElementById(“js_content”) 获取 id=”js_content”为正文部分</li><li>一些全局变量（特殊视频类文章除外）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器控制台输入 console.log(_ori_article_type,nickname,msg_title,msg_desc)</span><br><span class="line">var _ori_article_type = &quot;文章内容类型&quot;;</span><br><span class="line">var nickname = &quot;公众号名称&quot;;</span><br><span class="line">var msg_title = &quot;文章标题&quot;;</span><br><span class="line">var msg_desc = &quot;文章描述&quot;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="脚本重要代码段"><a href="#脚本重要代码段" class="headerlink" title="脚本重要代码段"></a>脚本重要代码段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var article = new Object();</span><br><span class="line">// 设置文章来源</span><br><span class="line">article.sourcename=&apos;微信公众号&apos;;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  // 设置文章标题</span><br><span class="line">  article.title = msg_title;</span><br><span class="line">  // 获取文章描述</span><br><span class="line">  article.summary= msg_desc;</span><br><span class="line">&#125; catch (e)&#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当文章为分享类，点击 阅读原文 按钮 跳转到源文章地址</span><br><span class="line">var shareContent = document.getElementById(&quot;js_share_content&quot;)</span><br><span class="line">var sourceBut = document.getElementById(&quot;js_share_source&quot;);</span><br><span class="line">if (shareContent &amp;&amp; sourceBut) &#123;</span><br><span class="line">  sourceBut.click();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除小程序卡片</span><br><span class="line">var deleteElements = document.getElementsByClassName(&quot;weapp_display_element js_weapp_display_element&quot;)</span><br><span class="line">for(var i=0;i&lt;deleteElements.length;i++) &#123;</span><br><span class="line">   deleteElements[i].remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取文章内容  </span><br><span class="line">var contentElement = document.getElementById(&apos;js_content&apos;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化专题-理论篇</title>
      <link href="/2018/07/22/performance-theory/"/>
      <url>/2018/07/22/performance-theory/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><strong>Fast is better than slow.</strong>   – <a href="https://www.jianshu.com/p/162454cf2241" target="_blank" rel="noopener">Ten things we know to be true</a></p></blockquote><a id="more"></a><h1 id="优化标准-RAIL模型"><a href="#优化标准-RAIL模型" class="headerlink" title="优化标准-RAIL模型"></a>优化标准-RAIL模型</h1><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li>以用户为中心；最终目标不是让您的网站在任何特定设备上都能运行很快，而是使用户满意。</li><li>立即响应用户；在 100 毫秒以内确认用户输入。</li><li>设置动画或滚动时，在 10 毫秒以内生成帧。</li><li>最大程度增加主线程的空闲时间。</li><li>持续吸引用户；在 1000 毫秒以内呈现交互内容。</li></ul><p>要根据 RAIL 指标评估您的网站，请使用 <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Chrome DevTools performance</a> 工具记录用户操作。然后根据这些关键 RAIL 指标检查记录时间。</p><h2 id="延迟与用户反应"><a href="#延迟与用户反应" class="headerlink" title="延迟与用户反应"></a>延迟与用户反应</h2><p>让用户成为您的性能工作的中心。用户花在网站上的大多数时间不是等待加载，而是在使用时等待响应。了解用户如何评价性能延迟：</p><style>table th:first-of-type {    width: 150px;}</style><table><thead><tr><th>延迟时间</th><th>用户体验</th></tr></thead><tbody><tr><td>0 ~ 16 ms</td><td>用户可以感知每秒渲染 60 帧的平滑动画转场，也就是每帧 16 毫秒。<br>留给应用大约 10 毫秒的时间来生成一帧。</td></tr><tr><td>0 ~ 100 ms</td><td>在此时间窗口内响应用户操作，他们会觉得可以立即获得结果。时间再长，操作与反应之间的连接就会中断。</td></tr><tr><td>100 ~ 300 ms</td><td>轻微可觉察的延迟。</td></tr><tr><td>300 ~ 1000 ms</td><td>延迟感觉像是任务自然和持续发展的一部分(用户觉得这是正常流，但不会觉得快)。</td></tr><tr><td>1000+ ms (&gt;1s)</td><td>用户的注意力将离开他们正在执行的任务。</td></tr><tr><td>10,000+ ms (&gt;10s)</td><td>用户感到失望，可能会放弃任务；之后他们或许不会再回来。</td></tr></tbody></table><p>Google团队提出了RAIL模型作为优化的目标。 Google把交互的过程分成4个独立的模块，称为 RAIL。RAIL 是一种以用户为中心的性能模型。每个网络应用均具有与其生命周期有关的四个不同方面，且这些方面以不同的方式影响着性能：response （响应）、 animation（动画）、idle（浏览器空置状态）和 load（加载）。<br><img src="/image/performance-theory/RAIL.png" alt="RAIL"></p><h2 id="RAIL模型"><a href="#RAIL模型" class="headerlink" title="RAIL模型"></a>RAIL模型</h2><h3 id><a href="#" class="headerlink" title></a><span class="label info">response响应 – 在100ms内响应</span></h3><p>在用户注意到滞后之前您有 100 毫秒的时间可以响应用户输入。这适用于大多数输入，不管他们是在点击按钮、切换表单控件还是启动动画。但不适用于触摸拖动或滚动。</p><p><strong>要得到响应式的回应，我们需要：</strong></p><ul><li>输入延迟时间（从按下到绘制）小于 100 毫秒。</li><li>如果最终结果需要花长时间才能得到，就要给一个“加载”的标识来告诉用户“还在处理中”。</li></ul><h3 id="-1"><a href="#-1" class="headerlink" title></a><span class="label info">Animation动画 – 在10ms内生成一帧</span></h3><p>在数学上来说，人眼感受到的帧数为60帧/s，则会认为是流畅的动画（1s/60 = 1000ms/60 = 16ms/帧）；也就是说加上每一帧的预算是16ms，减去浏览器绘制帧的时间，留给我们的大约只有10ms/帧。 如果超过这个时间，用户眼中动画的流畅度就会降低。动画包含了以下概念:</p><ul><li>视觉动画 ：这个包括了动画的开始和退出，状态改变时的动画，还有加载标识。 </li><li>滚动 ：当用户开始滚动页面，页面出现猛动的情况。 </li><li>拖拽 ：当我们需要对用户的拖拽交互在100毫秒以内做出响应时，比如平移地图或者缩放屏幕时，我们需要依赖动画。 </li></ul><p><strong>要合理地生成动画，我们需要：</strong></p><ul><li>每个帧的工作（从 JS 到绘制）完成时间小于 16 毫秒。 </li></ul><h3 id="-2"><a href="#-2" class="headerlink" title></a><span class="label info">IDLE 空闲 – 利用空闲的时间完成推迟的工作</span></h3><p><strong>要合理地应用浏览器空闲时间，我们需要：</strong></p><ul><li>尽可能减少预加载数据，以便您的应用快速加载。不是需要立刻传达给用户的，所以可以在浏览器空闲的时候再处理这些任务。</li><li>推迟的工作应分成每个耗时约 50 毫秒的多个块，因为应用应在 100 毫秒内给出响应。</li><li>如果用户开始交互，优先级最高的事项是响应用户。</li></ul><h3 id="-3"><a href="#-3" class="headerlink" title></a><span class="label info">LOAD 加载 – 在1000ms内呈现内容</span></h3><p><strong>页面加载时间是最常见的性能话题。 要尽快将页面加载出来，我们需要：</strong></p><ul><li>把最需要传达的、对用户来说最有意义的内容在 1000ms 内渲染出来。</li><li>要持续响应用户，绝对不允许出现在滚动页面、轻触或者看动画的时候卡顿。</li><li>优先考虑关键渲染路径，将所有不需要在加载时处理的任务延迟到浏览器空闲时再处理（或根据需求拦加载）。 </li></ul><hr><h1 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h1><h2 id="浏览器渲染进程"><a href="#浏览器渲染进程" class="headerlink" title="浏览器渲染进程"></a>浏览器渲染进程</h2><p>要想知道网页会卡顿在哪个阶段、哪些阶段可以进行性能优化，那么必须要对浏览器的渲染流程有个大体的了解。废话不多说，直接进入正题。</p><h3 id="浏览器的渲染进程是多线程的"><a href="#浏览器的渲染进程是多线程的" class="headerlink" title="浏览器的渲染进程是多线程的"></a>浏览器的渲染进程是多线程的</h3><h4 id="-4"><a href="#-4" class="headerlink" title></a><span class="label info">GUI渲染线程</span></h4><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。</li><li>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中 <strong>等到JS引擎空闲时</strong>立即被执行。</li></ul><h4 id="-5"><a href="#-5" class="headerlink" title></a><span class="label info">JS引擎线程</span></h4><ul><li>也称为JS内核，负责处理Javascript脚本程序，例如V8引擎。</li><li>JS引擎线程负责解析Javascript脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。</li><li>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><h4 id="-6"><a href="#-6" class="headerlink" title></a><span class="label info">事件触发线程</span></h4><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）。</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。</li></ul><h4 id="-7"><a href="#-7" class="headerlink" title></a><span class="label info">定时触发器线程</span></h4><ul><li>传说中的setInterval与setTimeout所在线程。</li><li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）。</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul><h4 id="-8"><a href="#-8" class="headerlink" title></a><span class="label info">异步http请求线程</span></h4><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求。</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就 <strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul><h3 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h3><ul><li>浏览器输入url，浏览器主进程接管，开一个下载线程。</li><li>然后进行http请求（略去DNS查询，IP寻址等等操作）。</li><li>接着等待响应，获取内容。</li><li>随后将内容通过RendererHost接口转交给Renderer进程，接着浏览器渲染流程开始。</li></ul><p><img src="/image/performance-theory/render.png" alt="render"></p><ol><li>处理 HTML 标记并构建 DOM 树、处理 CSS 标记并构建 CSSOM 树 。</li><li>结合DOM树和CSSDOM树形成render树， 也就是渲染树。</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算。</li><li>绘制render树（paint），绘制页面像素信息。</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li></ol><p><strong><em>优化关键渲染路径</em>就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间</strong></p><hr><h1 id="性能检测工具"><a href="#性能检测工具" class="headerlink" title="性能检测工具"></a>性能检测工具</h1><h2 id="Chrome-Devtools-–-Network"><a href="#Chrome-Devtools-–-Network" class="headerlink" title="Chrome Devtools – Network"></a>Chrome Devtools – Network</h2><blockquote><p>使用网络面板可以了解请求和下载的资源文件并优化网页加载性能。</p></blockquote><h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p>打开Chrome Devtools，选择Network标签。</p><h3 id="Request-Table-请求列表"><a href="#Request-Table-请求列表" class="headerlink" title="Request Table 请求列表"></a>Request Table 请求列表</h3><p>该视窗列出了所有的资源请求，默认按时间顺序排序，点击某个资源，可以查看更详细的信息：</p><ul><li>Headers：请求头信息和响应头信息。</li><li>Preview：预览结果。</li><li>Response：从服务器返回的响应结果。</li><li>Cookies：请求和响应的Cookie。</li><li>Timing：查看资源请求的生命周期。<ul><li>Queueing：浏览器会在以下情况对请求进行排队：有更高优先级的请求；在这个域下，已经有6个TCP连接了，达到Chrome最大限制数量。此条规则仅适用 在HTTP/1.0和HTTP/1.1。</li><li>Stalled：发送请求之前等待的时间。它可能因为进入队列的任意原因而被阻塞。这个时间包括代理协商的时间。</li><li>Proxy negotiation：浏览器与代理服务器协商消耗的时间。</li><li>DNS Lookup：浏览器对请求的IP地址进行DNS查找所消耗的时间。</li><li>Initial conncection：发起连接所消耗的时间。</li><li>Request sent：请求发送消耗的时间。</li><li>Waiting (TTFB)：浏览器等待响应的时间，TTFB表示 Time To First Byte。</li><li>Content Download：资源下载所消耗的时间。</li></ul></li></ul><h3 id="Summary-总览"><a href="#Summary-总览" class="headerlink" title="Summary 总览"></a>Summary 总览</h3><p>面板底部汇总了请求数量，传输数据大小，加载时间等信息,从左往右依次显示为：</p><ul><li>X requests：请求总个数。</li><li>X transferred：所有请求的大小。</li><li>Finish：加载完毕时间， 是页面上所有 http 请求发送到响应完成的时间。</li><li>DOMContentLoaded： DOM树构建完成时间。它在两个地方都有体现：概览视窗的蓝色竖线，总览视窗的触发时间。</li><li>Load：所有资源加载完成的时间。它在三个地方有体现：概览视窗的红色竖线，请求列表视窗的红色竖线，总览视窗的触发时间。</li></ul><blockquote><p>结合DOM文档加载的加载步骤，DOMContentLoaded事件/Load事件触发时机如下：<br>1、解析HTML结构。<br>2、加载外部脚本和样式表文件。<br>3、解析并执行脚本代码。        // 部分脚本会阻塞页面的加载<br>4、DOM树构建完成。            //DOMContentLoaded 事件<br>5、加载图片等外部文件。<br>6、页面加载完毕。             //load 事件</p></blockquote><h2 id="Chrome-Devtools-–-Performance"><a href="#Chrome-Devtools-–-Performance" class="headerlink" title="Chrome Devtools –  Performance"></a>Chrome Devtools –  Performance</h2><blockquote><p>使用性能面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能。</p></blockquote><h3 id="打开-1"><a href="#打开-1" class="headerlink" title="打开"></a>打开</h3><ol><li>打开<a href="https://googlechrome.github.io/devtools-samples/jank/" target="_blank" rel="noopener">指定网页</a>， 打开Chrome Devtools，然后选择Performance标签。</li><li>点击【record】开始录制，或点击reload按钮录制页面载入过程。</li><li>稍等片刻就会出现检测结果。</li></ol><h3 id="分析结果-–-分析每一秒的帧"><a href="#分析结果-–-分析每一秒的帧" class="headerlink" title="分析结果 – 分析每一秒的帧"></a>分析结果 – 分析每一秒的帧</h3><p>FPS（frames per second）是用来分析动画的一个主要性能指标。能保持在60的FPS的话，那么用户体验就是不错的。</p><ol><li>观察FPS图表，如果你发现了一个红色的长条，那么就说明这些帧存在严重问题，有可能导致非常差的用户体验。一般来说，绿色的长条越高，说明FPS越高，用户体验越好。<br><img src="/image/performance-theory/tool-fps.png" alt="FPS"></li><li>在Frames图表中，把鼠标移动到绿色条状图上，Devtools会展示这个帧的FPS。<br><img src="/image/performance-theory/tool-frames.png" alt="Frames"></li><li>勾选顶部的screenShots就可以看到各个时间点的界面截图，可以用来分析动画的各个细节。</li><li>另外一个好用的小工具就是实时FPS面板，它可以实时展示页面的FPS指标。<ul><li>打开more tools 里面 Randering面板，勾选 FPSmeter，FPS实时面板就出现在页面的右上方了。</li></ul></li><li>就在FPS图表下方，你会看到CPU图表。<ul><li>在CPU图表中的各种颜色与Summary面板里的颜色是相互对应的，Summary面板就在Performance面板的下方。</li><li>CPU图表中的各种颜色代表着在这个时间段内，CPU在各种处理上所花费的时间。</li><li>如果你看到了某个处理占用了大量的时间，那么这可能就是一个可以找到性能瓶颈的线索。详细看<a href="https://zhaoluting.github.io/2017/10/12/tool-devTool/">Chrome调试指南</a>。<br><img src="/image/performance-theory/tool-cpu.png" alt="CPU"></li></ul></li><li>展开Main图表，Devtools展示了主线程运行状况。<ul><li>X轴代表着时间。每个长条代表着一个event,长条越长就代表这个event花费的时间越长。</li><li>Y轴代表了调用栈。在栈里，上面的event调用了下面的event。<br><img src="/image/performance-theory/tool-main.png" alt="Main"></li></ul></li></ol><h2 id="Chrome-Devtools-–-Audits"><a href="#Chrome-Devtools-–-Audits" class="headerlink" title="Chrome Devtools –  Audits"></a>Chrome Devtools –  Audits</h2><blockquote><p>Audit标签使用了Google开源的一个自动化测试工具 – Lighthouse。可对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。</p></blockquote><h3 id="打开-2"><a href="#打开-2" class="headerlink" title="打开"></a>打开</h3><p>注意：这个工具需要翻墙，不然会卡在“lighthouse is warming up”。</p><ol><li>打开Chrome Devtools，然后选择Audits标签。</li><li>点击【Perform an audit…】，一般只检查【Performance】和【Best practices】即可，接着点击 Run audit 。</li><li>只需要等待一会儿，我们就完成了性能检查并且能把它当成衡量指标来提升网站的性能。</li></ol><h3 id="分析结果-综合分析"><a href="#分析结果-综合分析" class="headerlink" title="分析结果 - 综合分析"></a>分析结果 - 综合分析</h3><ul><li><span class="label info">Metrics 指标</span> —— Metrics下列举了基本的性能指标，并且给出页面加载时间的概览。<ul><li><strong>First meaningful paint</strong> —— 首次有效绘制：代表用户看到初始内容所需的时间。请尽量让它的值小于1秒。</li><li><strong>First interactive</strong> —— 首次互动：代表可交互元素从展示到响应所需的时间，即cpu有空闲能力来处理用户交互操作的时间。</li><li><strong>Consistently Interactive</strong> —— 持续互动：页面中的大多数网络资源完成加载并且CPU在很长一段时间都很空闲的所需的时间。</li><li><strong>Perceptual Speed Index</strong> —— 速度指标：页面加载性能指标，页面展示可见部分所需时间的平均值。以毫秒为单位并且取决于窗口的大小，应尽量减少到1250毫秒以内。</li><li><strong>Estimated Input Latency</strong> —— 预计输入延迟时间： 应用有 100 毫秒的时间响应用户输入。如果超过此时间，用户就会认为应用反应迟缓。</li></ul></li><li><span class="label info">Opportunities 可优化项</span> —— 这项里面的内容指的是LightHouse发现的一些可以直接优化的点，你可以对应这些点来进行优化。</li><li><span class="label info">Diagnostics 手动诊断项目</span> —— 这些项目表示LightHouse并不能替你决定当前是好是坏，但是把详情列出来，由你手动排查每个项目的情况。</li><li><span class="label info">Passed Audits 通过的审查项目</span> —— 这里列出的都是你做的好的地方，比如：减少阻塞渲染的脚本、图片懒加载、样式脚本压缩等等。</li><li><span class="label info">Best Practice 最佳实践</span> —— 本项指标是指LightHouse用业界公认的几项最佳实践来评估站点。</li></ul><h2 id="其他检测工具推荐"><a href="#其他检测工具推荐" class="headerlink" title="其他检测工具推荐"></a>其他检测工具推荐</h2><p>性能检测方面，Chrome DevTools已经很强大了，完全够用，除了我们常用的network、performance、auditing，More tools里面的Rendering、JavaScript Profiler、performance monitor等工具也很强大，所以，我就稍微介绍下其他工具：</p><ul><li><a href="https://www.cnblogs.com/strick/p/6677836.html" target="_blank" rel="noopener">WebPageTest</a>，很强大，也很复杂，有兴趣的可以去研究下；</li><li><a href="https://tools.pingdom.com/" target="_blank" rel="noopener">tools.pingdom.com</a> 可在线检测，兼具了Audits与Network标签对应的功能。</li></ul><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://developers.google.com/web/fundamentals/performance/rail" target="_blank" rel="noopener">RAIL</a><br><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/" target="_blank" rel="noopener">关键渲染路径</a><br><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a><br><a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">chrome-devtools官方文档</a><br><a href="https://www.breakyizhan.com/chromeconsole/1249.html" target="_blank" rel="noopener">Chrome 谷歌浏览器的开发者工具-Break驿站</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常规eslint配置</title>
      <link href="/2018/07/22/tool-eslint/"/>
      <url>/2018/07/22/tool-eslint/</url>
      
        <content type="html"><![CDATA[<h2 id="eslint配置过程"><a href="#eslint配置过程" class="headerlink" title="eslint配置过程"></a>eslint配置过程</h2><h3 id="安装需要依赖的npm包"><a href="#安装需要依赖的npm包" class="headerlink" title="安装需要依赖的npm包"></a>安装需要依赖的npm包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"eslint"</span>: <span class="string">"^4.19.1"</span>, <span class="comment">// 必须</span></span><br><span class="line"><span class="string">"babel-eslint"</span>: <span class="string">"^8.2.4"</span>, <span class="comment">// 支持babel</span></span><br><span class="line"><span class="string">"eslint-loader"</span>: <span class="string">"^2.0.0"</span>, <span class="comment">// 使webpack支持eslint</span></span><br><span class="line"><span class="string">"eslint-config-google"</span>: <span class="string">"^0.9.1"</span>, <span class="comment">// Google的ESLint可共享配置</span></span><br><span class="line"><span class="string">"eslint-plugin-vue"</span>: <span class="string">"^4.5.0"</span>, <span class="comment">// Vue.js的官方ESLint插件</span></span><br><span class="line"><span class="string">"eslint-plugin-import"</span>: <span class="string">"^2.13.0"</span>, <span class="comment">// 支持使用第三方的扩展</span></span><br></pre></td></tr></table></figure><p><strong>项目下运行命令行</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev eslint@4.19.1 babel-eslint@8.2.4 eslint-loader@2.0.0 eslint-config-google@0.9.1 eslint-plugin-vue@4.5.0 eslint-plugin-import@2.13.0</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="在项目最外层新建并编辑-eslintrc-js文件"><a href="#在项目最外层新建并编辑-eslintrc-js文件" class="headerlink" title="在项目最外层新建并编辑.eslintrc.js文件"></a>在项目最外层新建并编辑.eslintrc.js文件</h3><p><strong>加入以下代码</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，ESLint会在所有父级组件中寻找配置文件，一直到根目录。ESLint一旦发现配置文件中有 "root": true，它就会停止在父级目录中寻找。</span></span><br><span class="line">    <span class="string">"root"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 扩展流行的风格指南</span></span><br><span class="line">    <span class="string">"extends"</span>: [<span class="string">"plugin:vue/recommended"</span>, <span class="string">'plugin:vue/essential'</span>, <span class="string">"eslint:recommended"</span>, <span class="string">"google"</span>],</span><br><span class="line">    <span class="comment">// 此插件用来识别.html 和 .vue文件中的js代码</span></span><br><span class="line">    <span class="string">"plugins"</span>: [<span class="string">"import"</span>, <span class="string">"vue"</span>],</span><br><span class="line">    <span class="comment">// 对Babel解析器的包装使其与 ESLint 兼容。</span></span><br><span class="line">    <span class="string">"parserOptions"</span>: &#123;<span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>&#125;,</span><br><span class="line">    <span class="comment">// 自己的个性化规则</span></span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="comment">// 禁用 switch 中冒号前后的空格规则</span></span><br><span class="line">        <span class="string">"switch-colon-spacing"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用 jsdoc 规则</span></span><br><span class="line">        <span class="string">"require-jsdoc"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用每行字数限制规则</span></span><br><span class="line">        <span class="string">"max-len"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 允许打 console.log</span></span><br><span class="line">        <span class="string">"no-console"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 允许使用debugger语句</span></span><br><span class="line">        <span class="string">"no-debugger"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用代码块首尾必须要空行的规则</span></span><br><span class="line">        <span class="string">"padded-blocks"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 不检查行尾空格</span></span><br><span class="line">        <span class="string">"no-trailing-spaces"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 使用 === 替代 ==</span></span><br><span class="line">        <span class="string">"eqeqeq"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">"vue/no-parsing-error"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="comment">// 关闭标签闭合检查 </span></span><br><span class="line">            <span class="string">"x-invalid-end-tag"</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><p>“off” 或 0       =&gt; 关闭规则<br>“warn” 或 1      =&gt;开启规则，使用警告级别的错误：warn (不会导致程序退出)<br>“error” 或 2     =&gt;开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)</p></blockquote><p><strong>如果在webpack.config文件中设置了resolver配置，那么还需要:</strong></p><ul><li><p>安装<a href="https://www.npmjs.com/package/eslint-import-resolver-webpack" target="_blank" rel="noopener">eslint-import-resolver-webpack</a>依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i --save-dev eslint-import-resolver-webpack@0.10.1</span><br></pre></td></tr></table></figure></li><li><p>默认情况下，会从项目的compile/webpack.base.config.js文件中寻找webpack的resolver配置，但是这并不一定准确，因此可以自己重新配置正确的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"extends"</span>: [<span class="string">"plugin:vue/recommended"</span>, <span class="string">'plugin:vue/essential'</span>, <span class="string">"eslint:recommended"</span>, <span class="string">"google"</span>],</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">'import/resolver'</span>: &#123;</span><br><span class="line">            webpack: &#123;</span><br><span class="line">                config: <span class="string">'compile/webpack.base.conf.js'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="在webpack-config-js文件中添加配置"><a href="#在webpack-config-js文件中添加配置" class="headerlink" title="在webpack.config.js文件中添加配置"></a>在webpack.config.js文件中添加配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx|vue)$/</span>,</span><br><span class="line">        loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">        enforce: <span class="string">'pre'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="visio-studio-code-配置eslint"><a href="#visio-studio-code-配置eslint" class="headerlink" title="visio studio code 配置eslint"></a>visio studio code 配置eslint</h3><p><strong>如果想在代码编写时 使编辑器将错误代码用红色波浪线标出 并提示错误，那么就可以做下面几步：</strong></p><ol><li>左侧菜单栏选择“扩展”，搜索“eslint”、“Vetur”安装并重新加载</li><li><p>配置vscode实现对.vue .html文件中的js代码段的检测： 顶部选项Code -&gt; 首选项 -&gt; 设置，搜索编辑“eslint.validate”添加 “html”,”vue”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"eslint.validate"</span>: [</span><br><span class="line">      <span class="string">"javascript"</span>,</span><br><span class="line">      <span class="string">"javascriptreact"</span>,</span><br><span class="line">      <span class="string">"html"</span>,</span><br><span class="line">      <span class="string">"vue"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>可以打开项目中.vue文件，不规范的语法就都已经被红色波浪线标记出来了。</p></li></ol><h2 id="eslint修改技巧"><a href="#eslint修改技巧" class="headerlink" title="eslint修改技巧"></a>eslint修改技巧</h2><h3 id="eslint-–-fix-修复指令"><a href="#eslint-–-fix-修复指令" class="headerlink" title="eslint – fix 修复指令"></a>eslint – fix 修复指令</h3><ul><li><p>检查并修复项目所有代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules/.bin/eslint --fix *</span><br></pre></td></tr></table></figure></li><li><p>检查并修复指定文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules/.bin/eslint --fix app.js</span><br></pre></td></tr></table></figure></li><li><p><strong>tips: 如果直接运行  eslint – fix  会报 Cannot find module ‘@u51/eslint-config-web’ 的错误。</strong>  </p><blockquote><p>config文件是安装在当前项目，直接eslint –fix file调用的是全局的eslint，所以无法找到当前项目的config文件。故使用 node_modules/.bin/eslint –fix 。</p></blockquote></li></ul><h3 id="vscode-保存自动格式化eslint代码"><a href="#vscode-保存自动格式化eslint代码" class="headerlink" title="vscode 保存自动格式化eslint代码"></a>vscode 保存自动格式化eslint代码</h3><ul><li><p>进入【设置】加上以下配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"vetur.format.defaultFormatter.html"</span>: <span class="string">"js-beautify-html"</span>, <span class="comment">// 格式化.vue中html</span></span><br><span class="line">    <span class="string">"vetur.format.defaultFormatter.js"</span>: <span class="string">"vscode-typescript"</span>, <span class="comment">// 让vue中的js按编辑器自带的ts格式进行格式化</span></span><br><span class="line">    <span class="string">"eslint.enable"</span>: <span class="keyword">true</span>,</span><br><span class="line">    <span class="string">"eslint.autoFixOnSave"</span>:<span class="keyword">true</span>, <span class="comment">// 保存时自动fix</span></span><br><span class="line">    <span class="string">"eslint.run"</span>: <span class="string">"onType"</span>,</span><br><span class="line">    <span class="string">"eslint.options"</span>: &#123;<span class="string">"extensions"</span>: [<span class="string">".js"</span>,<span class="string">".vue"</span>]&#125;,</span><br><span class="line">    <span class="string">"eslint.validate"</span>: [</span><br><span class="line">        <span class="string">"javascript"</span>,</span><br><span class="line">        <span class="string">"javascriptreact"</span>,</span><br><span class="line">        <span class="string">"html"</span>,</span><br><span class="line">        &#123;<span class="string">"language"</span>: <span class="string">"vue"</span>, <span class="string">"autoFix"</span>: <span class="keyword">true</span>&#125; <span class="comment">//开启对.vue文件中错误的检查</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启后，右键“格式化文件”或者修改文件后点击“保存”，就可自动格式化代码了。</p></li></ul><h3 id="忽略ESLint检测"><a href="#忽略ESLint检测" class="headerlink" title="忽略ESLint检测"></a>忽略ESLint检测</h3><p>如果需要修改代码量太大，可以先将未修改的文件忽略掉，以后逐步修改。</p><ul><li><p>新建.eslintignore文件，放置需要ESLint忽略的文件。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules/</span><br><span class="line">src/components/input-tag.vue</span><br></pre></td></tr></table></figure></li><li><p>将 <span class="label success">/* eslint-disable */</span>块注释放在文件顶部，可以在整个文件范围内禁止规则出现警告。</p></li><li><span class="label success">// eslint-disable-next-line</span> 可关闭下一行校验。</li></ul><h3 id="命令行检测、修改文件"><a href="#命令行检测、修改文件" class="headerlink" title="命令行检测、修改文件"></a>命令行检测、修改文件</h3><ul><li><p>打开package.json，在script里加入:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -ext 后面写上指定检测文件的后缀，紧接着写上要检测的目录，即可用命令行来检测。</span></span><br><span class="line"><span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.jsx,.vue src/"</span>,</span><br><span class="line"><span class="comment">// 加上--fix，即可在检测的同时将文件自动格式化。</span></span><br><span class="line"><span class="string">"lint-fix"</span>: <span class="string">"eslint --fix --ext .js,.jsx,.vue src/"</span>,</span><br></pre></td></tr></table></figure></li><li><p>终端运行 <span class="label default">npm run lint</span> 或者 <span class="label default">npm run lint-fix</span></p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/default.md" target="_blank" rel="noopener">eslint规则说明</a><br><a href="http://eslint.cn/" target="_blank" rel="noopener">ESLint官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何提高前端的自测能力</title>
      <link href="/2018/06/27/ability-slefTest/"/>
      <url>/2018/06/27/ability-slefTest/</url>
      
        <content type="html"><![CDATA[<p><div class="note info">一个小菜鸟的感悟与总结</div></p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><span class="label success"> // 最常见的三种测试类型。单元测试主要由开发人员来做，功能测试与集成测试由测试人员来做。</span><p><strong>单元测试</strong>：指对软件中的最小可测试单元进行检查和验证；<br><strong>功能测试</strong>：对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能；<br><strong>集成测试</strong>：也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图〕组装成为子系统或系统，进行集成测试；</p><a id="more"></a><span class="label success"> // 客户端主要是用黑盒测试，服务端主要用白盒测试，灰盒测试比较少用。</span><p><strong>黑盒测试</strong>：也称功能测试，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。<br><strong>白盒测试</strong>：也称结构测试或逻辑驱动测试，它是知道产品内部工作过程，可通过测试来检测产品内部动作是否按照规格说明书的规定正常进行，按照程序内部的结构测试程序，检验程序中的每条通路是否都有能按预定要求正确工作。<br><strong>灰盒测试</strong>：介于黑盒白盒二者之间，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态。有时候输出是正确的，但内部其实已经错误了，这种情况非常多。</p><h2 id="前端自测三个方面"><a href="#前端自测三个方面" class="headerlink" title="前端自测三个方面"></a>前端自测三个方面</h2><p>1、界面交互是否符合要求、逻辑<br>2、接口请求是否正确<br>3、数据展示是否准确</p><h2 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h2><ul><li><strong>公用记录型</strong>：JIRA（推荐）、wiki（没有测试人员时可以简单记在wiki上）</li><li><strong>自用记录型</strong>：mac自带备忘录、有道云笔记、Excel、XMind</li><li><strong>接口测试工具</strong>：swagger、postman</li><li><strong>代码内部测试工具</strong>：eslint、karma 等等</li></ul><h2 id="平时积累的技巧"><a href="#平时积累的技巧" class="headerlink" title="平时积累的技巧"></a>平时积累的技巧</h2><h3 id="问（很重要）"><a href="#问（很重要）" class="headerlink" title="问（很重要）"></a>问（很重要）</h3><span class="label success"> // 公司测试小哥说这点是最重要。</span><ul><li>问清楚项目需求，对需求理解透彻；</li><li>向经验丰富的开发、测试人员讨教经验；</li><li>询问用户的使用体验及意见；</li></ul><h3 id="列"><a href="#列" class="headerlink" title="列"></a>列</h3><ul><li>需求点要清楚得罗列出来，产品或者后端没有罗列就自己罗列。</li><li>每做完一个需求就做个标记，每提一个bug也要列进去。</li><li>优点是整个开发过程会很清晰，日后排期、更改需求也有参照，有据可循。</li><li>缺点就是费时。</li></ul><blockquote><p>例如下图，需求多时，花点时间理清思路，用markdown等工具列出来：</p></blockquote><p><img src="/image/selfTest/list.png" alt="罗列需求"></p><blockquote><p>又例如下图（优化与修复），有较多bug或优化点时，用wiki做一个表格，方便产品验收：</p></blockquote><p><img src="/image/selfTest/bugList.png" alt="罗列Bug">  </p><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul><li>代码里多写备注，readme文件不能偷懒，不留坑也方便转手；</li><li>commit 多打字，提交历史会很清晰；</li><li>发布系统里不随便填写信息，需求列表会很清楚；<br><img src="/image/selfTest/featList.png" alt="需求列表">  </li></ul><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul><li>每次提交代码前利用工具检查修改过的内容。（全局搜下有没有未去掉的debugger，搜“&lt;&lt;&lt;&lt;&lt;”看有没有冲突代码）;<br><img src="/image/selfTest/code.png" alt="代码">  </li><li>发布前有时间就顺手检查下提交历史;<br><img src="/image/selfTest/gitlab.png" alt="代码">  </li></ul><h3 id="学"><a href="#学" class="headerlink" title="学"></a>学</h3><ul><li>多学习其他优秀系统的交互与设计，对比思考自己做的那些系统的不足；</li><li>平时多学习交互规范、用户体验设计类的书籍，让自己更加专业；</li></ul><p><strong>论坛网站</strong>：<a href="http://bbs.51testing.com/forum.php" target="_blank" rel="noopener">51testing软件测试论坛</a><br><strong>学习文档</strong>：软件工程中的测试技术(第一部分).pdf、软件工程中的测试技术(第二部分).pdf<br><strong>测试相关的学习资料不是很多</strong>，主要还是靠平时实践的积累，理论的话看上面的《软件工程中的测试技术》就差不多了。</p><h2 id="几个常用组件的checklist"><a href="#几个常用组件的checklist" class="headerlink" title="几个常用组件的checklist"></a>几个常用组件的checklist</h2><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><ul><li><strong>各种<span class="label success">数据类型</span>的输入情况:</strong> 全汉字输入、全英文输入、全字符输入、全数字输入、混搭输入、大小写处理、半/全角输入;</li><li><strong>数字需要关注<span class="label success">边界值</span>:</strong> 最大/小值、正/负数、小数点保留位;</li><li><strong>不同的输入<span class="label success">文本长度</span>:</strong>为空、文本溢出、文本未溢出;</li><li><strong>输入框<span class="label success">校验规则</span>:</strong>为空校验、数据类型校验、正则检测、多个数据之间大小校验;</li><li><strong>保障<span class="label success">数据准确性</span>:</strong>输入输出结果是否一致、数据是否进行处理;</li><li><strong><span class="label success">隐藏部分</span>的显示:</strong>选择下拉框的文本显示溢出情况、日期时间选择框是否超出屏幕、选择下拉框数据量过大的情况;</li><li><strong><span class="label success">操作按钮</span>检查:</strong>字段完整性检查、快键建检查、回车键检查、重复提交检查;</li><li><strong><span class="label success">安全性</span>检查:</strong>恶意代码注入;</li><li><strong>屏幕大小不同情况下的<span class="label success">自适应</span>:</strong>浏览器置于桌面、浏览器全屏、浏览器投放至大显;</li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul><li><strong>各种<span class="label success">数据类型</span>的显示情况:</strong> 全汉字、全英文、全字符、全数字、混搭、大小写识别;</li><li><strong>不同<span class="label success">文本长度</span>:</strong> 为空、短文本、超长文本、数字位数保留;</li><li><strong>保障<span class="label success">数据准确性</span>:</strong> 显示结果是否正确、是否进行格式/映射处理、映射为空时的情况;</li><li><strong><span class="label success">脱敏情况</span>:</strong>身份证号、手机等数据是否脱敏完全;</li><li><strong>屏幕大小不同情况下的<span class="label success">自适应</span>:</strong>浏览器置于桌面、浏览器全屏、浏览器投放至大显;</li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li><strong><span class="label success">表格展示</span>情况:</strong>列表为空、列数过多、数据量过大、loading状态、是否错位;</li><li><strong>单元格内不同<span class="label success">文本长度</span>:</strong>为空、文本溢出、文本未溢出;</li><li><strong>单元格内各种<span class="label success">数据类型</span>的显示情况:</strong>全汉字、全英文、全字符、全数字、混搭;</li><li><strong>保障<span class="label success">数据准确性</span></strong>:<ul><li>单元格显示结果是否正确、是否进行格式/映射处理、映射为空时的情况;</li><li>整个表格数据分页是否准确、选中时结果是否一致、筛选排序结果是否正确;</li></ul></li><li><strong>屏幕大小不同情况下的<span class="label success">自适应</span>:</strong>浏览器置于桌面、浏览器全屏、浏览器投放至大显;</li></ul><h3 id="附件上传"><a href="#附件上传" class="headerlink" title="附件上传"></a>附件上传</h3><ul><li><strong><span class="label success">附件显示情况</span>:</strong>不同尺寸文件预览的显示、不同文件格式预览的显示、文件预览失败/不存在时的显示、文件预览加载过慢的情况;</li><li><strong><span class="label success">附件准确性</span>:</strong>是否错位展示;</li><li><strong><span class="label success">安全性</span>检查:</strong>上传时脚本后缀改为图片等格式（文件内容校验）;</li><li><strong>屏幕大小不同情况下的<span class="label success">自适应</span>:</strong>浏览器置于桌面、浏览器全屏、浏览器投放至大显;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 能力 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js的异步IO机制</title>
      <link href="/2018/05/29/node-asynchronous/"/>
      <url>/2018/05/29/node-asynchronous/</url>
      
        <content type="html"><![CDATA[<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p><strong>单线程</strong>、<strong>异步非阻塞I/O</strong>、<strong>事件驱动</strong> 是Node.js的三大闪光点。其中，理解异步非阻塞I/O模型是学习node过程中的一大难点。</p><a id="more"></a><h3 id="什么是I-O"><a href="#什么是I-O" class="headerlink" title="什么是I/O"></a>什么是I/O</h3><p>I/O在计算机中指Input/Output，也就是输入和输出，分为I/O设备和I/O接口两个部分。</p><ul><li>I/O接口是CPU和I/O设备之间交换信息的媒介和桥梁。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等。</li><li>现代计算机系统中配置了大量的外围设备，即I/O设备。通常进行如下分类：<ul><li>字符设备，又叫做人机交互设备，例如，键盘和显示器为一体的字符终端、打印机、鼠标等。</li><li>块设备，又叫外部存储器，用户通过这些设备实现程序和数据的长期保存，如磁盘、光盘等。</li><li>网络通信设备。这类设备主要有网卡、调制解调器等，主要用于与远程设备的通信。</li></ul></li></ul><h3 id="同步与异步I-O"><a href="#同步与异步I-O" class="headerlink" title="同步与异步I/O"></a>同步与异步I/O</h3><p>由于CPU和内存的速度远远高于外设的速度，所以，在I/O编程中，就存在速度严重不匹配的问题。比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p><ul><li>同步I/O：CPU等待，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行。</li><li>异步I/O：CPU不等待，后续代码可以立刻接着执行。<ul><li>实现方式1：主动轮询异步调用的结果。</li><li>实现方式2：被调用方通过callback来通知调用方调用结果。</li></ul></li></ul><blockquote><p>同步和异步是一种通信机制，涉及到调用方和被调用方，关注的是I/O操作的执行过程及结果的返回方式，不同点在于双方在这两个方面的行为方式。</p></blockquote><h3 id="阻塞与非阻塞I-O"><a href="#阻塞与非阻塞I-O" class="headerlink" title="阻塞与非阻塞I/O"></a>阻塞与非阻塞I/O</h3><ul><li>阻塞I/O：调用结果返回之前，该执行线程会被挂起，不释放CPU执行权，线程不能做其它事情，只有等到调用结果返回了，才能接着往下执行</li><li>非阻塞I/O：在没有获取调用结果时，线程可以往下执行，而不是等待。<ul><li>如果是同步的，会通过轮询的方式检查有没有调用结果返回；</li><li>如果是异步的，会通知回调。</li></ul></li></ul><blockquote><p>阻塞和非阻塞是一种调用机制，只涉及到调用方，关注的是I/O操作的执行状态，不同点在于请求I/O操作后，针对I/O操作的状态，调用方的行为方式。</p></blockquote><h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><p>故事：老张烧开水。<br>出场人物：老张，普通水壶，会响的水壶。</p><ol><li>老张把水壶放到火上，立等水开。<strong>（同步阻塞）</strong> </li><li>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。<strong>（同步非阻塞）</strong>     </li><li>老张买了把会响笛的水壶。水开之后能发出嘀~~~~的噪音。老张把响水壶放火上，立等水开。<strong>（异步阻塞）</strong> </li><li>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。<strong>（异步非阻塞）</strong>   </li></ol><p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。 </p><p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，电视放什么他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p><h2 id="Node-js与异步"><a href="#Node-js与异步" class="headerlink" title="Node.js与异步"></a>Node.js与异步</h2><h3 id="Node为什么要选择异步？"><a href="#Node为什么要选择异步？" class="headerlink" title="Node为什么要选择异步？"></a>Node为什么要选择异步？</h3><h4 id="1、前提条件：JavaScript是单线程的"><a href="#1、前提条件：JavaScript是单线程的" class="headerlink" title="1、前提条件：JavaScript是单线程的"></a>1、前提条件：JavaScript是单线程的</h4><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<strong>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</strong></p><blockquote><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p></blockquote><h4 id="2、从用户体验角度讲，异步I-O可以消除UI阻塞，快速响应资源"><a href="#2、从用户体验角度讲，异步I-O可以消除UI阻塞，快速响应资源" class="headerlink" title="2、从用户体验角度讲，异步I/O可以消除UI阻塞，快速响应资源"></a>2、从用户体验角度讲，异步I/O可以消除UI阻塞，快速响应资源</h4><ul><li>JavaScript是单线程的，它与UI渲染共用一个线程。所以在JavaScript执行的时候，UI渲染将处于停顿的状态，用户体验较差。而异步请求可以在下载资源的时候，JavaScript和UI渲染都同时执行，消除UI阻塞，降低响应资源需要的时间开销。</li><li>假如一个资源来自两个不同位置的数据的返回，第一个资源需要M毫秒的耗时，第二个资源需要N毫秒的耗时。<ul><li>当采用同步的方式，总耗时为（M+N）毫秒。</li><li>当采用异步的方式，总耗时为max（M，N）毫秒。</li></ul></li></ul><h4 id="3、从资源分配角度讲，异步I-O可以让单线程远离阻塞，以更好地利用CPU"><a href="#3、从资源分配角度讲，异步I-O可以让单线程远离阻塞，以更好地利用CPU" class="headerlink" title="3、从资源分配角度讲，异步I/O可以让单线程远离阻塞，以更好地利用CPU"></a>3、从资源分配角度讲，异步I/O可以让单线程远离阻塞，以更好地利用CPU</h4><ul><li>假设业务线上有一组互不相关的任务需要完成，现行的主流方法有以下两种：<ul><li>单线程同步执行：会阻塞I/O导致硬件资源和CPU得不到更优的使用。</li><li>多线程并发执行：会出现死锁、状态同步等问题。</li></ul></li><li>Node的解决方案<ul><li>利用单线程远离多线程的死锁、状态同步等问题。</li><li>利用异步I/O，让单线程远离阻塞，更好的利CPU。</li></ul></li></ul><h3 id="Node如何实现异步I-O？"><a href="#Node如何实现异步I-O？" class="headerlink" title="Node如何实现异步I/O？"></a>Node如何实现异步I/O？</h3><p><strong>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</strong><br><img src="/image/asynchronous/异步流程图.png" alt="异步流程图"><br>整个实现过程大概更可以描述为：  </p><ul><li>发起异步请求之后将请求进行封装，封装为请求对象，对请求对象设置参数和回调函数并将请求对象放入线程池，线程池中检查是否有可用线程，当线程可用时执行请求对象的I/O操作，并将执行完成的结果放入请求对象中，通知IOCP调用完成并获取完成的I/O交给I/O观察者。</li><li>在libuv中创建主循环开始事件循环，主循环从I/O观察者中取出可用的请求对象，在请求对象中取出回调函数和I/O结果并调用回调函数。</li></ul><h4 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h4><ul><li><p>观察者：事件循环判断是否有事件待执行，就是通过询问观察者，观察者不会主动通知进程，而是进程询问时才返回结果。 </p><blockquote><p>事件循环是生产者/消费者模型。异步I/O和网络请求是事件的生产者，这些事件被输送到观察者，事件循环是消费者，从观察者这里取出事件处理。观察者就相当于模型中的缓冲区，生产者不断产生事件放到缓冲区，而消费者从缓冲区里取出事件进行消费。</p></blockquote></li><li><p>libuv：libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。它是Node.js实现异步的核心。</p></li><li><p>请求对象：从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，叫做请求对象。从JavaScript传入的参数和当前方法都被封装在这个请求对象中，其中回调函数则被设置在这个对象的oncomplete_sym属性上。<br><img src="/image/asynchronous/请求对象.png" alt="请求对象"><br>假设fs.open()，根据指定路径和参数打开文件。在JS发起调用后，JS调用Node的核心模块（lib/fs.js），核心模块调用C++内建模块(node_file.cc)，內建模块通过libuv判断平台(是*nix还是win)并进行系统调用。在进行系统调用时，从JS层传入的方法和参数都被封装在一个请求对象FSReqWrap中，请求对象被放在线程池中等待执行。JS立即返回继续下面的操作。</p></li><li><p>I/O线程池：在Node中，JS是在单线程中执行的，但是内部完成I/O工作的另有线程池，使用一个主进程和多个I/O线程来模拟异步I/O。当主线程发起I/O调用时，I/O操作会被放在I/O线程来执行，主线程继续执行下面的任务。I/O操作不管是否阻塞，都不会影响JS执行线程的执行。在I/O线程完成操作后会带着数据通知主线程发起回调。<br><img src="/image/asynchronous/多线程.png" alt="多线程"><br><strong>因此，Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程。</strong></p></li><li><p>事件队列：Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</p></li><li><p>事件循环 (Event Loop)：在进程启动时，Node会创建一个类似于While(true)的循环，每执行一次循环体的过程称为Tick。每个Tick过程中观察者会查看是否有事件需要处理，如果有就取出事件及其相关的回调函数并执行。然后进入下一个Tick。如果没有事件处理，就退出进程。<br><img src="/image/asynchronous/事件循环.png" alt="事件循环"></p></li><li><p>执行回调：I/O执行结束后，会将结果通知IOCP（windows下,linux下epoll），并将线程归还线程池。使用事件循环的I/O观察者，如果有已经执行完的I/O，则将请求对象加入I/O观察者队列中，事件循环再Tick过程中，检测到有I/O观察者，则取出其中的请求对象，再取出请求对象中的回调函数执行。 </p></li></ul><h4 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟"></a>代码模拟</h4><p>Node.js 实现异步的核心是事件，也就是说，它把每一个任务都当成 事件 来处理，然后通过 Event Loop 模拟了异步的效果，为了更具体、更清晰的理解和接受这个事实，下面我们用伪代码来描述一下其工作原理 。</p><h5 id="【1】定义事件队列"><a href="#【1】定义事件队列" class="headerlink" title="【1】定义事件队列"></a>【1】定义事件队列</h5><p>既然是队列，那就是一个先进先出 (FIFO) 的数据结构，我们用JS数组来描述，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义事件队列</span></span><br><span class="line"><span class="comment"> * 入队：push()</span></span><br><span class="line"><span class="comment"> * 出队：shift()</span></span><br><span class="line"><span class="comment"> * 空队列：length == 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">globalEventQueue: []</span><br></pre></td></tr></table></figure><p>我们利用数组来模拟队列结构：数组的第一个元素是队列的头部，数组的最后一个元素是队列的尾部，push() 就是在队列尾部插入一个元素，shift() 就是从队列头部弹出一个元素。这样就实现了一个简单的事件队列。</p><h5 id="【2】定义接收请求入口"><a href="#【2】定义接收请求入口" class="headerlink" title="【2】定义接收请求入口"></a>【2】定义接收请求入口</h5><p>每一个请求都会被拦截并进入处理函数，如下所示： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收用户请求</span></span><br><span class="line"><span class="comment"> * 每一个请求都会进入到该函数</span></span><br><span class="line"><span class="comment"> * 传递参数request和response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">processHttpRequest:<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 定义一个事件对象</span></span><br><span class="line">    <span class="keyword">var</span> event = createEvent(&#123;</span><br><span class="line">        params:request.params, <span class="comment">// 传递请求参数</span></span><br><span class="line">        result:<span class="literal">null</span>, <span class="comment">// 存放请求结果</span></span><br><span class="line">        callback:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 指定回调函数</span></span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在队列的尾部添加该事件  </span></span><br><span class="line">    globalEventQueue.push(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是把用户的请求包装成事件，放到队列里，然后继续接收其他请求。</p><h5 id="【3】定义-Event-Loop"><a href="#【3】定义-Event-Loop" class="headerlink" title="【3】定义 Event Loop"></a>【3】定义 Event Loop</h5><p>当主线程处于空闲时就开始循环事件队列，所以我们还要定义一个函数来循环事件队列：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件循环主体，主线程择机执行</span></span><br><span class="line"><span class="comment"> * 循环遍历事件队列</span></span><br><span class="line"><span class="comment"> * 处理非I/O任务</span></span><br><span class="line"><span class="comment"> * 处理I/O任务</span></span><br><span class="line"><span class="comment"> * 执行回调，返回给上层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">eventLoop:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果队列不为空，就继续循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.globalEventQueue.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 从队列的头部拿出一个事件</span></span><br><span class="line">        <span class="keyword">var</span> event = <span class="keyword">this</span>.globalEventQueue.shift();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 如果是耗时任务</span></span><br><span class="line">        <span class="keyword">if</span>(isIOTask(event))&#123;</span><br><span class="line">            <span class="comment">// 从线程池里拿出一个线程</span></span><br><span class="line">            <span class="keyword">var</span> thread = getThreadFromThreadPool();</span><br><span class="line">            <span class="comment">// 交给线程处理</span></span><br><span class="line">            thread.handleIOTask(event)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非耗时任务处理后，直接返回结果</span></span><br><span class="line">            <span class="keyword">var</span> result = handleEvent(event);</span><br><span class="line">            <span class="comment">// 最终通过回调函数返回给V8，再由V8返回给应用程序</span></span><br><span class="line">            event.callback.call(<span class="literal">null</span>,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主线程不停的检测事件队列，对于 I/O 任务，就交给线程池来处理，非 I/O 任务就自己处理并返回。</p><h5 id="【4】处理-I-O-任务"><a href="#【4】处理-I-O-任务" class="headerlink" title="【4】处理 I/O 任务"></a>【4】处理 I/O 任务</h5><p>线程池接到任务以后，直接处理I/O操作，比如读取数据库：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理I/O任务</span></span><br><span class="line"><span class="comment"> * 完成后将事件添加到队列尾部</span></span><br><span class="line"><span class="comment"> * 释放线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">handleIOTask:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    <span class="keyword">var</span> curThread = <span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 操作数据库</span></span><br><span class="line">    <span class="keyword">var</span> optDatabase = <span class="function"><span class="keyword">function</span>(<span class="params">params,callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = readDataFromDb(params);</span><br><span class="line">        callback.call(<span class="literal">null</span>,result)</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 执行I/O任务</span></span><br><span class="line">    optDatabase(event.params,<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 返回结果存入事件对象中</span></span><br><span class="line">        event.result = result;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// I/O完成后，将不再是耗时任务</span></span><br><span class="line">        event.isIOTask = <span class="literal">false</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 将该事件重新添加到队列的尾部</span></span><br><span class="line">        <span class="keyword">this</span>.globalEventQueue.push(event);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 释放当前线程</span></span><br><span class="line">        releaseThread(curThread)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 I/O 任务完成以后就执行回调，把请求结果存入事件中，并将该事件重新放入队列中，等待循环，最后释放当前线程，当主线程再次循环到该事件时，就直接处理了。</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>Node.js通过事件驱动模型实现了高并发和异步 I/O，然而也有 Node.js 不擅长做的事情：<br>上面提到，如果是 I/O 任务，Node.js 就把任务交给线程池来异步处理，高效简单，因此 Node.js 适合处理I/O密集型任务。<br>但不是所有的任务都是I/O密集型任务，当碰到CPU密集型任务时，即只用CPU计算的操作，比如要对数据加解密、数据压缩和解压，这时Node.js就会亲自处理，一个一个的计算，前面的任务没有执行完，后面的任务就只能干等着。<br>在事件队列中，如果前面的CPU计算任务没有完成，后面的任务就会被阻塞，出现响应缓慢的情况，如果操作系统本身就是单核，那也就算了，但现在大部分服务器都是多CPU或多核的，而Node.js只有一个Event Loop，也就是只占用一个CPU内核，当Node.js被CPU密集型任务占用，导致其他任务被阻塞时，却还有CPU内核处于闲置状态，造成资源浪费。<br><strong>因此，Node.js 并不适合 CPU 密集型任务。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Nodejs实际上只是应用程序层面JavaScript单线程执行，真正I/O操作、网络请求、底层API调用都是多线程执行。</li><li>事件循环是Node异步I/O实现的核心，Node通过事件驱动的方式处理请求，使得其无须为每个请求创建额外的线程，省掉了创建和销毁线程的开销。同时也因为线程数较少，不受线程上下文切换的影响，维持了Node的高性能。</li><li>Nodejs具备单线程执行应用程序、异步非阻塞I/O的特点，因此适用于I/O密集型场景，而并不擅长于CPU计算密集型场景。</li></ul><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a><br><a href="https://my.oschina.net/zhangjiawen/blog/1551020?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">单线程NodeJS的异步I/O</a><br><a href="https://blog.csdn.net/pengpengrose0406/article/details/46964595" target="_blank" rel="noopener">[读书笔记]深入浅出NodeJS——Node中的异步I/O</a><br><a href="https://www.cnblogs.com/onepixel/p/7143769.html" target="_blank" rel="noopener">Node.js 事件循环机制</a><br><a href="https://juejin.im/post/5ab367acf265da23a049783e" target="_blank" rel="noopener">JS/NodeJS中的异步任务与事件环</a><br><a href="https://github.com/zhaoluting/asynchronous/blob/master/深入浅出Node.js.pdf" target="_blank" rel="noopener">深入浅出node.js</a>   </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向前端的数据库指南</title>
      <link href="/2018/03/08/sql-guide/"/>
      <url>/2018/03/08/sql-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库概览"><a href="#数据库概览" class="headerlink" title="数据库概览"></a>数据库概览</h1><p>一般一个数据库系统（Database System）可分为数据库（Database）与数据管理系统（Database Management System，DBMS）两个部分。数据库就是按照数据结构来组织、存储和管理数据的仓库，管理这个数据库的软件就称之为数据库管理系统。<a href="https://www.zhihu.com/question/21091495/answer/17197897" target="_blank" rel="noopener">也可以更形象地类比成中药铺子。</a></p><a id="more"></a><h2 id="关系型与非关系型"><a href="#关系型与非关系型" class="headerlink" title="关系型与非关系型"></a>关系型与非关系型</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ol><li>以行和列的形式存储数据，结构稳定，具有逻辑性，易于理解，但不易修改。</li><li>查询能力强，可以操作很复杂的查询。</li><li>一致性高。由于并发高，在数据同步的时候一般采用锁来保证数据的可靠性。</li><li>事务支持使得对于安全性能很高的数据访问要求得以实现。</li></ol><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><ol><li>非关系型数据库主要使用key-value的方式存储数据，即是“no relational”，由于数据间没有关联性，相对来说层级扁平。而且不需要经过SQL层的解析，所以性能非常高。</li><li>可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li><li>数据结构灵活，每个数据都可以有不同的结构。</li><li>由于降低了一致性的要求，所以查询速度更快。</li><li>不适用于复杂SQL操作。</li><li>不支持事务。</li></ol><h3 id="关系型数据库-V-S-非关系型数据库"><a href="#关系型数据库-V-S-非关系型数据库" class="headerlink" title="关系型数据库  V.S.  非关系型数据库"></a>关系型数据库  V.S.  非关系型数据库</h3><p>关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点，这个特性使得关系型数据库可以用于几乎所有对一致性有要求的系统中，如典型的银行系统。相反地，关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，而像微博、facebook这类SNS的应用，对并发读写能力要求极高；另外，其固定的表结构，因此，其扩展性极差。</p><p>于是，非关系型数据库应运而生，由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。必须强调的是，数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库这员老将。</p><h2 id="主流数据库"><a href="#主流数据库" class="headerlink" title="主流数据库"></a>主流数据库</h2><p><a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">数据库排行榜</a>中商业Oracle、微软SQLServer、免费MySQL，三者是目前市场占有率最高（依安装量而非收入）的关系数据库，而且很有代表性。</p><h3 id="三大关系型数据库"><a href="#三大关系型数据库" class="headerlink" title="三大关系型数据库"></a>三大关系型数据库</h3><ol><li>Oracle<br>Oracle主要应用在传统行业的数据化业务中，比如：银行、金融这样的对可用性、健壮性、安全性、实时性要求极高的业务；零售、物流这样对海量数据存储分析要求很高的业务。而且由于Oracle对复杂计算、统计分析的强大支持，在互联网数据分析、数据挖掘方面的应用也越来越多。</li><li>MySQL<br>MySQL基本是生于互联网，长于互联网。其应用实例也大都集中于互联网方向，MySQL的高并发存取能力并不比大型数据库差，同时价格便宜，安装使用简便快捷，深受广大互联网公司的喜爱。最大的一个特色，就是自由选择存储引擎。每个表都是一个文件，都可以选择合适的存储引擎。常见的引擎有 InnoDB、 MyISAM、 NDBCluster等。并且由于MySQL的开源特性，针对一些对数据库有特别要求的应用，可以通过修改代码来实现定向优化，例如SNS、LBS等互联网业务。</li><li>MS SQLServer<br>windows生态系统的产品，好处坏处都很分明。好处就是，高度集成化，微软也提供了整套的软件方案，基本上一套win系统装下来就齐活了。因此，不那么缺钱，但很缺IT人才的中小企业，会偏爱 MS SQL Server。例如，自建ERP系统、商业智能、垂直领域零售商、餐饮、事业单位等等。</li></ol><h3 id="两大非关系型数据库"><a href="#两大非关系型数据库" class="headerlink" title="两大非关系型数据库"></a>两大非关系型数据库</h3><p>NoSQL主要有以下几类：临时性键值存储（memcached、Redis）、永久性键值存储（ROMA、Redis）、面向文档的数据库（MongoDB、CouchDB）、面向列的数据库（Cassandra、HBase）。最热门的是MongoDB 和 Redis。下面从以下几个维度对redis、mongoDB进行对比：</p><ol><li><p>性能<br>性能都比较高，总体来讲，TPS方面redis优于mongodb；</p></li><li><p>可操作性<br>redis数据丰富，较少的网络IO次数；<br>mongodb支持丰富的数据表达、索引，类似关系型数据库MySQL，支持的查询语言非常丰富。<br>总体来讲，MongoDB优于Redis。</p></li><li><p>内存空间的大小和数据量的大小<br>redis在2.0版本后增加了自己的VM特性，突破物理内存的限制，可以对key value设置过期时间（类似memcache）；<br>mongoDB适合大数据量存储，依赖系统虚拟内存管理，采用镜像文件存储；内存占有率比较高，官方建议独立部署在64位系统。<br>不同的应用角度看，各有优势。</p></li><li><p>可用性<br>redis依赖客户端来实现分布式读写，主从复制时，每次从节点重新连接主节点都要依赖整个快照,无增量复制；不支持自动sharding,需要依赖程序设定一致hash机制。<br>mongoDB支持master-slave,replicaset（内部采用paxos选举算法，自动故障恢复）,auto sharding机制，对客户端屏蔽了故障转移和切分机制。<br>总体来讲，MongoDB优于Redis；单点问题上，MongoDB应用简单，相对用户透明，Redis比较复杂，需要客户端主动解决。</p></li><li><p>可靠性(持久化)<br>redis依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响;<br>MongoDB从1.8版本开始采用binlog方式（MySQL同样采用该方式）支持持久化的可靠性。<br>对于数据持久化和数据恢复，MongoDB优于Redis</p></li></ol><ol start="6"><li><p>数据一致性（事务支持）<br>redis事务支持比较弱，只能保证事务中的每个操作连续执行;<br>mongoDB不支持事务。<br>此方面，Redis优于MongoDB。</p></li><li><p>数据分析<br>mongoDB内置了数据分析的功能，Redis不支持</p></li><li><p>应用场景<br>redis：数据量较小的更性能操作和运算上;<br>MongoDB:主要解决海量数据的访问效率问题。</p></li></ol><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>组内推荐使用MySQL，所以接下来介绍下MySQL。</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="主键-primary-key"><a href="#主键-primary-key" class="headerlink" title="主键(primary key)"></a>主键(primary key)</h3><p>能够唯一标识表中某一行的属性或属性组。一个表只能有一个主键，但可以有多个候选索引。主键常常与外键构成参照完整性约束，防止出现数据不一致。主键可以保证记录的唯一和主键域非空,数据库管理系统对于主键自动生成唯一索引，所以主键也是一个特殊的索引。</p><h3 id="外键（foreign-key）"><a href="#外键（foreign-key）" class="headerlink" title="外键（foreign key）"></a>外键（foreign key）</h3><p>是用于建立和加强两个表数据之间的链接的一列或多列。外键约束主要用来维护两个表之间数据的一致性。简言之，表的外键就是另一表的主键，外键将两表联系起来。一般情况下，要删除一张表中的主键必须首先要确保其它表中的没有相同外键（即该表中的主键没有一个外键和它相关联）。</p><h3 id="约束（constraints）"><a href="#约束（constraints）" class="headerlink" title="约束（constraints）"></a>约束（constraints）</h3><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。<br>常用SQL约束：</p><ul><li>NOT NULL - 非空约束，指定某列不为空。</li><li>UNIQUE - 保证某列的每行必须有唯一的值。</li><li>PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li>FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li>CHECK - 保证列中的值符合指定的条件。</li><li>DEFAULT - 规定没有给列赋值时的默认值。</li></ul><h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引(index)"></a>索引(index)</h3><p>是用来快速地寻找那些具有特定值的记录。主要是为了检索的方便，是为了加快访问速度， 按一定的规则创建的，一般起到排序作用。所谓唯一性索引，这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一。</p><h3 id="存储过程-proceduer"><a href="#存储过程-proceduer" class="headerlink" title="存储过程(proceduer)"></a>存储过程(proceduer)</h3><p>存储过程是保存在数据库上的一段可执行代码。与java中的函数类似。通过一系列的SQL语句，根据传入的参数（也可以没有），通过简单的调用，完成比单个SQL语句更复杂的功能，存储在数据库服务器端，只需要编译过一次之后再次使用都不需要再进行编译。主要对存储的过程进行控制。</p><h3 id="触发器-trigger"><a href="#触发器-trigger" class="headerlink" title="触发器(trigger)"></a>触发器(trigger)</h3><p>触发器是一个特殊的存储过程，不同的是存储过程要用CALL来调用，而触发器不需要使用CALL也不需要手工启动，只要当一个预定义的事件发生的时候，就会被MYSQL自动调用。触发器可以让你在执行INSERT,UPDATE或者DELETE的时候，执行一些特定的操作，可以在MYSQL中指定实在SQL语句执行前触发还是执行后触发。</p><h3 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h3><p>特点：</p><ul><li>原子性(atomicity)：组成事务处理的语句形成了一个逻辑单元，不能只执行其中的一部分。</li><li>一致性(consistency)：在事务处理执行前后，数据库是一致的(数据库数据完整性约束)。</li><li>隔离性(isolcation)：一个事务处理对另一个事务处理的影响。</li><li>持续性(durability)：事务处理的效果能够被永久保存下来 。</li></ul><p>过程：</p><ul><li>Start transaction：开始一个事务。  </li><li>Commit：提交所做的修改。  </li><li>Rollback：回滚所做的修改。如果在操作时出错，应该从新开始一个事务。</li></ul><p>总结：事务从Start transaction到Commit或者Rollback结束，这中间的语句是一个整体，如果执行Rollback，那么这些动作都会回滚。如果执行Commit那么这些动作全部执行成功。</p><h3 id="锁-lock"><a href="#锁-lock" class="headerlink" title="锁(lock)"></a>锁(lock)</h3><p>InnoDB主要实现了两种类型的行锁：共享锁和排它锁。InnoDB行锁是通过给索引项加锁实现的，如果没有索引，InnoDB会通过隐藏的聚簇索引来对记录加锁。对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁。 </p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同的数据集的排他锁（我读的时候，你可以读，但是不能写）。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，但是组织其他事务获得相同数据集的共享锁和排他锁（我写的时候，你不能读也不能写）。</li></ul><p><strong>何时在InnoDB中使用表锁：</strong><br>InnoDB在绝大部分情况会使用行级锁，因为事务和行锁往往是我们选择InnoDB的原因，但是在如下情况我们也考虑使用表级锁：</p><ul><li>当事务需要更新大部分数据时，表又比较大，如果使用默认的行锁，不仅效率低，而且还容易造成其他事务长时间等待和锁冲突。</li><li>事务比较复杂，很可能引起死锁导致回滚。</li></ul><p><strong>避免死锁</strong><br>在InnoDB中，锁是逐步获得的，就造成了死锁的可能。当两个事务都需要获得对方持有的锁才能够继续完成事务，导致双方都在等待，就会产生死锁。有多种方法可以避免死锁，这里只介绍常见的三种：</p><ul><li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会；</li><li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li></ul><h3 id="MySQL三大范式和反范式"><a href="#MySQL三大范式和反范式" class="headerlink" title="MySQL三大范式和反范式"></a>MySQL三大范式和反范式</h3><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。但是有些时候一昧的追求范式减少冗余，反而会降低数据读写的效率，这个时候就要反范式，利用空间来换时间。</p><ul><li>第一范式：确保每列的原子性。</li><li>第二范式：确保表中的每列都和主键相关。</li><li>第三范式：确保每列都和主键列直接相关,而不是间接相关。</li><li>反三范式：没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，减少了查询时的关联，提高查询效率，因为在数据库的操作中查询的比例要远远大于DML的比例。但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>首先安装MySQL，可参照此教程=&gt;<a href="http://blog.csdn.net/catstarxcode/article/details/78940385" target="_blank" rel="noopener">Mac安装MySQL</a>。（注：一定要记住临时密码并重置）；</li><li>安装可视化工具：sequel pro或者Navicat都可以（我用<a href="https://sequelpro.com/" target="_blank" rel="noopener">sequel pro</a>举例）；</li><li><p>然后打开 sequel pro就可以在里面进行与数据库的连接，连接时输入的信息有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host –在本机上面就输入本机的IP地址（127.0.0.1），   </span><br><span class="line">username – 默认是 root   </span><br><span class="line">password – 就是数据库的密码   </span><br><span class="line">database – 可以不填   </span><br><span class="line">port – 端口号 默认是 3306</span><br></pre></td></tr></table></figure></li><li><p>连接后就可以进行各种操作啦（附上简单<a href="https://segmentfault.com/a/1190000006255923" target="_blank" rel="noopener">教程</a>）</p></li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>基本会增删改查即可（<a href="http://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">SQL语法学习地址</a>）</p><ul><li>SELECT - 从数据库中提取数据</li><li>UPDATE - 更新数据库中的数据</li><li>DELETE - 从数据库中删除数据</li><li>INSERT INTO - 向数据库中插入新数据</li><li>CREATE DATABASE - 创建新数据库</li><li>ALTER DATABASE - 修改数据库</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li>CREATE INDEX - 创建索引（搜索键）</li><li>DROP INDEX - 删除索引</li></ul><h2 id="争议点"><a href="#争议点" class="headerlink" title="争议点"></a>争议点</h2><h3 id="该不该摒弃外键"><a href="#该不该摒弃外键" class="headerlink" title="该不该摒弃外键"></a>该不该摒弃外键</h3><h4 id="矛盾焦点"><a href="#矛盾焦点" class="headerlink" title="矛盾焦点"></a>矛盾焦点</h4><p>数据库设计是否需要外键。这里有两个问题：一个是如何保证数据库数据的完整性和一致性；二是第一条对性能的影响。</p><h4 id="正方观点"><a href="#正方观点" class="headerlink" title="正方观点"></a>正方观点</h4><ol><li>由数据库自身保证数据一致性，完整性，更可靠，因为程序很难100％保证数据的完整性，而用外键即使在数据库服务器当机或者出现其他问题的时候，也能够最大限度的保证数据的一致性和完整性。</li><li>有主外键的数据库设计可以增加ER图的可读性，这点在数据库设计时非常重要。</li><li>外键在一定程度上说明的业务逻辑，会使设计周到具体全面。</li></ol><h4 id="反方观点"><a href="#反方观点" class="headerlink" title="反方观点"></a>反方观点</h4><ol><li>数据库需要维护外键的内部管理；</li><li>外键等于把数据的一致性事务实现，全部交给数据库服务器完成，可控性就会降低。你自己写代码控制的话，相当于许多数据逻辑自己控制，虽然麻烦，但是出了问题有利于自己查找并针对性解决。</li><li>有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，进行完整性检查是一个耗费时间和资源的过程。在并发小的情况下，这种开销应该没什么区别，但是在高并发的情况下，数据库的外键对性能的影响肯定是很高的；</li><li>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；</li><li>可以用事务或应用程序保证数据的完整性。</li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>外键是否采用看业务应用场景，以及开发成本的，大致列下什么时候适合，什么时候不适合使用：</p><ol><li>互联网行业应用不推荐使用外键：<br>用户量大，并发度高，为此数据库服务器很容易成为性能瓶颈，尤其受IO能力限制，且不能轻易地水平扩展；若是把数据一致性的控制放到事务中，也即让应用服务器承担此部分的压力，而引用服务器一般都是可以做到轻松地水平的伸缩；</li><li><p>传统行业建议使用外键：<br>软件应用的人数有限，换句话说是可控的；数据库服务器的数据量也一般不会超大，且活跃数据有限。综合上述2句话描述，也即数据库服务器的性能不是问题，所以不用过多考虑性能的问题；另外，使用外键可以降低开发成本，借助数据库产品自身的触发器可以实现表与关联表之间的数据一致性和更新；最后一点，使用外键的方式，还可以做到开发人员和数据库设计人员的分工，可以为程序员承担更多的工作量；</p></li><li><p>需要注意的是：MySQL允许使用外键，但是为了完整性检验的目的，在除了InnoDB表类型之外的所有表类型中都忽略了这个功能。如果需要更好的性能，并且不需要完整性检查，可以选择使用MyISAM表类型，如果想要在MySQL中根据参照完整性来建立表并且希望在此基础上保持良好的性能，最好选择表结构为innoDB类型。</p></li></ol><h2 id="学习重点"><a href="#学习重点" class="headerlink" title="学习重点"></a>学习重点</h2><ul><li>熟练运用增删改查命令</li><li>用事务来代替外键来保证完整性</li><li>用索引提高查询速度</li><li>熟练运用锁来优化数据库</li></ul><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p>《MySQL必知必会》（适合入门）<br>《高性能MySQL》<br>《MySQL技术内幕-innorDB搜索引擎》</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac terminal入门篇</title>
      <link href="/2018/01/25/tool-zsh/"/>
      <url>/2018/01/25/tool-zsh/</url>
      
        <content type="html"><![CDATA[<h2 id="了解mac-terminal（终端）"><a href="#了解mac-terminal（终端）" class="headerlink" title="了解mac terminal（终端）"></a>了解mac terminal（终端）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system_profiler    <span class="comment">#显示Mac的硬件和软件信息</span></span><br><span class="line">sw_vers            <span class="comment">#显示OSX系统版本</span></span><br><span class="line">uname -av          <span class="comment">#显示OS X Darwin内核版本</span></span><br></pre></td></tr></table></figure><p>简单来说：  </p><ul><li>unix是最早的出来的多任务、多用户系统，是对源代码实行知识产权保护的传统商业软件，是收费的。 </li><li>linux是一个牛人为了让人们用到免费的类unix系统，开发出了linux的内核，是开放源代码的自由软件。</li><li>mac os x是由Unix的一个分支(BSD)发展过来的，核心叫darwin(达尔文)。</li></ul><p>在unix 内核的操作系统中,包括衍生出来的分支linux、OS X等，所有文件都挂在跟目录 / 下面，没有Windows下的盘符概念。</p><a id="more"></a><table><thead><tr><th>位置</th><th>路径</th><th>备注</th></tr></thead><tbody><tr><td>根目录</td><td>/mach_kernel</td><td>内核就在这</td></tr><tr><td>驱动所在</td><td>/Systme/Library/Extensions</td><td></td></tr><tr><td>用户文件夹(home folder)</td><td>/User/用户名</td><td>简写：~</td></tr><tr><td>桌面</td><td>/User/用户名/Desktop</td><td></td></tr><tr><td>当前目录</td><td>.</td><td></td></tr><tr><td>父目录</td><td>..</td><td></td></tr></tbody></table><blockquote><p>注意：在 Unix系统中是区别大小写字符的，并且对于文件名，必须包括扩展名。</p></blockquote><h2 id="快速打开终端"><a href="#快速打开终端" class="headerlink" title="快速打开终端"></a>快速打开终端</h2><ol><li>spotlight方法：首先用快捷键打开spotlight（command+空格），输入ter，自动显示出终端全称，按enter即可打开终端。  </li><li>Finder打开：Finder——应用程序——实用工具——终端  </li><li>快捷键完成当前文件夹打开终端：打开“系统偏好设置”——键盘——快捷键——服务，找到“新建位于文件夹位置的终端窗口”打钩。之后，只要在文件夹上 右键——服务——“新建位于文件夹位置的终端窗口” 即可。</li></ol><h2 id="终级Shell–zsh"><a href="#终级Shell–zsh" class="headerlink" title="终级Shell–zsh"></a>终级Shell–zsh</h2><p>shell 是我们和系统内核指令打交道的一座桥梁,我们通过键盘输入一种自己容易记忆识别的符号标识(shell 命令)，然后 shell 解析这种命令再反馈给内核去执行一系列操作。</p><p><strong>可以通过以下命令查看安装了哪些shell（OS X 系统预装了zsh）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p><strong>查看系统默认的shell</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure></p><p><strong>将默认shell改成zsh</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p><blockquote><p>zsh是shell的一种，由于配置过于复杂，以至于很多人并不常用他。所以大多数Linux产品默认使用的都是bash shell。直到一个开源项目的出现<a href="http://ohmyz.sh" target="_blank" rel="noopener">oh my zsh</a>，github来管理zsh的配置和支持更多插件，使得zsh配置变得更容易，使用起来更加强大。以至于他有了个外号—<strong>终极shell</strong>。</p></blockquote><p><strong>安装oh my zsh</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure></p><p><strong>配置文件路径：</strong> ~/.zshrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">大部分配置都可以在配置文件中进行设置，这里大概翻译一下。</span><br><span class="line"></span><br><span class="line"><span class="comment"># ZSH的环境变量</span></span><br><span class="line"><span class="built_in">export</span> ZSH=/Users/dawang/.oh-my-zsh</span><br><span class="line"><span class="comment"># 主题设置</span></span><br><span class="line"><span class="comment"># 主题列表在 ~/.oh-my-zsh/themes/</span></span><br><span class="line"><span class="comment"># [主题列表](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)</span></span><br><span class="line"><span class="comment"># 如果设置为 "random", 每次开启都会是不同的主题</span></span><br><span class="line">ZSH_THEME=<span class="string">"robbyrussell"</span></span><br><span class="line"><span class="comment"># 如果想要大小写敏感，可以取消注释下面的一行</span></span><br><span class="line"><span class="comment"># CASE_SENSITIVE="true"</span></span><br><span class="line"><span class="comment"># 如果想要连接符不敏感，可以取消注释下面的一行。_ 和 - 将可以互换</span></span><br><span class="line"><span class="comment"># HYPHEN_INSENSITIVE="true"</span></span><br><span class="line"><span class="comment"># 如果不想要自动更新，可以取消注释下面的一行</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_UPDATE="true"</span></span><br><span class="line"><span class="comment"># 自动更新的时间间隔，单位是天，这里设置 30 天更新一次</span></span><br><span class="line"><span class="built_in">export</span> UPDATE_ZSH_DAYS=30</span><br><span class="line"><span class="comment"># 如果不想要 ls 命令输出带颜色，可以取消注释下面的一行</span></span><br><span class="line"><span class="comment"># DISABLE_LS_COLORS="true"</span></span><br><span class="line"><span class="comment"># 是否禁止更改终端标题,不要禁止,不然所有终端tab只显示zsh了,而不随着目录的改变而改变显示</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_TITLE="true"</span></span><br><span class="line"><span class="comment"># 自动纠正命令,不启用,不怎么好用</span></span><br><span class="line"><span class="comment"># ENABLE_CORRECTION="true"</span></span><br><span class="line"><span class="comment"># 按tab键补全命令的时候,如果没什么可补全的就会出现三个红点</span></span><br><span class="line"><span class="comment"># COMPLETION_WAITING_DOTS="true"</span></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to disable marking untracked files</span></span><br><span class="line"><span class="comment"># under VCS as dirty. This makes repository status check for large repositories</span></span><br><span class="line"><span class="comment"># much, much faster.</span></span><br><span class="line"><span class="comment"># 不要在意这些细节，不需要改动</span></span><br><span class="line"><span class="comment"># DISABLE_UNTRACKED_FILES_DIRTY="true"</span></span><br><span class="line"><span class="comment"># 历史命令日期显示格式</span></span><br><span class="line"><span class="comment"># 有三种方式: "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"</span></span><br><span class="line"><span class="comment"># HIST_STAMPS="yyyy-mm-dd"</span></span><br><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line"><span class="comment"># Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)</span></span><br><span class="line"><span class="comment"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="comment"># 插件设置，如果添加太多启动速度会比较慢</span></span><br><span class="line">plugins=(git autojump)</span><br><span class="line">[[ -s ~/.autojump/etc/profile.d/autojump.zsh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.zsh</span><br><span class="line"><span class="comment"># 剩下部分比较不常改动 </span></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/TeX/texbin"</span></span><br><span class="line"><span class="comment"># export MANPATH="/usr/local/man:$MANPATH"</span></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"><span class="comment"># You may need to manually set your language environment</span></span><br><span class="line"><span class="comment"># export LANG=en_US.UTF-8</span></span><br><span class="line"><span class="comment"># Preferred editor for local and remote sessions</span></span><br><span class="line"><span class="comment"># if [[ -n $SSH_CONNECTION ]]; then</span></span><br><span class="line"><span class="comment">#   export EDITOR='vim'</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line"><span class="comment">#   export EDITOR='mvim'</span></span><br><span class="line"><span class="comment"># fi</span></span><br><span class="line"><span class="comment"># Compilation flags</span></span><br><span class="line"><span class="comment"># export ARCHFLAGS="-arch x86_64"</span></span><br><span class="line"><span class="comment"># ssh</span></span><br><span class="line"><span class="comment"># export SSH_KEY_PATH="~/.ssh/dsa_id"</span></span><br><span class="line"><span class="comment"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span></span><br><span class="line"><span class="comment"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span></span><br><span class="line"><span class="comment"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span></span><br><span class="line"><span class="comment"># For a full list of active aliases, run `alias`.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example aliases</span></span><br><span class="line"><span class="comment"># alias zshconfig="mate ~/.zshrc"</span></span><br><span class="line"><span class="comment"># alias ohmyzsh="mate ~/.oh-my-zsh"</span></span><br></pre></td></tr></table></figure><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ol><li>插件相关的文件在~/.oh-my-zsh/plugins目录下，默认提供了100多种。插件也是在.zshrc里配置，找到plugins关键字，系统默认加载git与autojump，可以在后面追加启用插件。</li></ol><ul><li><p>git：当你处于一个 git 受控的目录下时，Shell 会明确显示 「git」和 branch。另外对git 很多命令进行了简化，例如 gco=’git checkout’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zsh</p></li><li><p>安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全。</p></li></ul><ol start="2"><li><p>配置文件底部可以设置 alias（通用别名），还能针对文件类型设置对应的打开程序。</p></li><li><p>连按两次Tab会列出所有的补全列表并直接开始选择，补全项可以使用 ctrl+n/p/f/b 或 方向键上下左右切换。</p></li><li><p>在zsh中只需要键入 ls -<tab> 就会列出所有的选项和帮助说明。  </tab></p></li><li><p>命令参数补全。键入 kill <tab> 就会列出所有的进程名和对应的进程号。</tab></p></li><li><p>更智能的历史命令。在用或者方向上键查找历史命令时，zsh支持限制查找。比如，输入ls,然后再按方向上键，则只会查找用过的ls命令。</p></li><li><p>多个终端会话共享历史记录。</p></li><li><p>目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</p></li><li><p>在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。在你知道路径的情况下，比如 /usr/local/bin 你可以输入 cd /u/l/b 然后按进行补全快速输入。</p></li><li><p>通配符搜索：例如“ls -l **/*.sh”，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find。使用 **/ 来递归搜索。</p></li><li><p>如何在命令里面打回车： \ 后面接回车</p></li><li><p>一句话执行两个命令： xxx; yyy</p></li><li><p>一句话执行两个命令： xxx&amp;&amp; yyy</p></li></ol><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>光标左移：Ctrl + B</li><li>光标右移：Ctrl + F</li><li>光标至行首：Ctrl + A</li><li>光标至行尾：Ctrl + E</li><li>删除至行首：Ctrl + U</li><li>删除至行尾：Ctrl + K</li><li>删除至单词开始：Ctrl + W</li><li>清屏：Ctrl + L</li><li>插入最近删除：Ctrl + Y</li><li>历史命令：↑ 或 ↓箭头，或 ⌃ + P、Ctrl + N</li><li>搜索历史命令：Ctrl + R</li><li>中止执行：Ctrl + C</li><li>按住 ⌘，单击路径可以在 Finder 中打开</li></ul><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><table><thead><tr><th>命令</th><th>全写</th><th>缩写   </th></tr></thead><tbody><tr><td>创建目录</td><td>make directory</td><td>mkdir </td></tr><tr><td>删除</td><td>remove</td><td>rm</td></tr><tr><td>移动/重命名</td><td>move</td><td>mv</td></tr><tr><td>复制</td><td>copy</td><td>cp</td></tr><tr><td>罗列</td><td>list</td><td>ls</td></tr><tr><td>链接</td><td>link</td><td>ln *</td></tr></tbody></table><h3 id="常用的通配符"><a href="#常用的通配符" class="headerlink" title="常用的通配符"></a>常用的通配符</h3><ul><li>星号（＊，Asterisk）——代表任何长度的任何字符。例如*.tiff代表所有格式为tiff的文件。</li><li>问号（?，Question mark）——代表任何单个字符。例如b?ok匹配 book 但是不匹配 brook。</li><li>方括号（[]，Square brackets）——定义一定范围的字符，例如[Dd]ocument匹配 Document 以及 document；doc[1-9]匹配doc1, doc2, …, doc9。  </li></ul><h3 id="处理特殊字符"><a href="#处理特殊字符" class="headerlink" title="处理特殊字符"></a>处理特殊字符</h3><ul><li><p>如果目录中有特殊字符（空格，括号，引号，[]，!，$，&amp;，*，;，|，\），那么直接输入空格会造成系统识别困难，必须使用特殊的语法来表示这些字符。例如上例中，空格前添加反斜杠“\”（back slash）即可：cd Punlic/Drop\ Box/。除了反斜杠，也可以用引号的方法：cd “Public/Drop Box”。</p></li><li><p>如果不想手动输入，也可以把文件从 Finder 拖到 Terminal 窗口来创建绝对路径，这会方便一些，因为上面提到的所有特殊字符在拖动后都会自动变成系统可识别的表示方法。</p></li><li><p>更有效率的解决方案是使用 Tab Complete 功能。连按两次Tab进行选择。Tab complete 同样会处理那些特殊字符。</p></li></ul><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="列出文件"><a href="#列出文件" class="headerlink" title="列出文件"></a>列出文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 参数 目录名</span><br></pre></td></tr></table></figure><p>以下为常用参数，可组合使用。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）。 </td></tr><tr><td>-A</td><td>显示除影藏文件“.”和“..”以外的所有文件列表。 </td></tr><tr><td>-d</td><td>仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表。 </td></tr><tr><td>-l</td><td>以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等。 </td></tr><tr><td>-R</td><td>递归处理，将指定目录下的所有文件及子目录一并处理； –full-time：列出完整的日期与时间； –color[=WHEN]：使用不同的颜色高亮显示不同类型的。 </td></tr></tbody></table><h3 id="转换目录"><a href="#转换目录" class="headerlink" title="转换目录"></a>转换目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>     <span class="comment">#含义是“print working directory”，会显示当前目录的绝对路径。</span></span><br><span class="line"><span class="built_in">cd</span> 路径  <span class="comment">#改变当前目录到你指定的目录。不指定则会返回 home folder</span></span><br></pre></td></tr></table></figure><h3 id="打开文件目录或程序"><a href="#打开文件目录或程序" class="headerlink" title="打开文件目录或程序"></a>打开文件目录或程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open /Applications/Safari.app/  <span class="comment">#打开应用</span></span><br><span class="line">open .  <span class="comment">#打开当前目录。</span></span><br></pre></td></tr></table></figure><h3 id="建立新目录"><a href="#建立新目录" class="headerlink" title="建立新目录"></a>建立新目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 目录名</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>递归创建目录，如果文件不存在，则逐层创建目录。</td></tr><tr><td>-v</td><td>显示目录创建的信息。</td></tr></tbody></table><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名   <span class="comment">#主要功能与时间戳有关，用来更新文件的访问和修改时间。如果文件不存在，会创建相应的空文件</span></span><br></pre></td></tr></table></figure><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp 参数 源文件 目标文件</span><br><span class="line"></span><br><span class="line">cp file /usr/men/tmp/file1  <span class="comment">#将文件file复制到目录/usr/men/tmp下，并改名为file1</span></span><br><span class="line"></span><br><span class="line">cp -r /usr/men /usr/zh      <span class="comment">#将目录/usr/men下的所有文件及其子目录复制到目录/usr/zh中</span></span><br><span class="line"></span><br><span class="line">cp -i /usr/men m*.c /usr/zh <span class="comment">#交互式地将目录/usr/men中的以m打头的所有.c文件复制到目录/usr/zh中（覆盖之前询问用户）</span></span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm  foo.txt        <span class="comment">#删除一般文件  </span></span><br><span class="line">rm  -r  foofolder  <span class="comment">#删除目录</span></span><br><span class="line">rm  -r  *          <span class="comment">#删除当前目录下的所有文件及目录</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>删除目录时必需参数；  </td></tr><tr><td>-i</td><td>删除前逐一询问确认；  </td></tr><tr><td>－rf</td><td>表示递归和强制，千万要小心使用，如果执行了 rm -rf / 就全没了</td></tr></tbody></table><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv file1 file2      <span class="comment">#（若目标是文件名，则相当于文件改名）将文件 file1 改名为 file2。</span></span><br><span class="line">mv file1 file2 /tmp <span class="comment">#将文件 file1 和文件 file2 移动到目录 /tmp 下</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>- i</td><td>在覆盖已存在文件时作提示，若回答 y 则覆盖，其他则中止</td></tr><tr><td>- f</td><td>覆盖前不作任何提示</td></tr></tbody></table><h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><table><thead><tr><th>编辑器</th><th>特点</th></tr></thead><tbody><tr><td>vi</td><td>老式的简单文本编辑器</td></tr><tr><td>vim</td><td>复杂的文本编辑器，相当于vi的升级版</td></tr><tr><td>nano</td><td>小巧自由的舒适型编辑器</td></tr></tbody></table><h4 id="nano"><a href="#nano" class="headerlink" title="nano"></a><a href="http://man.linuxde.net/nano" target="_blank" rel="noopener">nano</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano 路径+文件名 <span class="comment">#若文件存在将打开这个文件；不存在则会创建新文件并打开。</span></span><br></pre></td></tr></table></figure><ul><li>复制一整行：Alt+6</li><li>剪贴一整行：Ctrl+K</li><li>粘贴：Ctrl+U</li><li>搜索: Ctrl+W，然后输入你要搜索的关键字，回车确定，定位到第一个匹配的文本，接着可用Alt+W来定位到下一个匹配的文本。</li><li>翻页到上一页：Ctrl+Y</li><li>翻页到下一页：Ctrl+V</li><li>保存：Ctrl+O 保存所做的修改</li><li>退出：Ctrl+X。如果你修改了文件，下面会询问你是否需要保存修改。输入Y确认保存，输入N不保存，按Ctrl+C取消返回。如果输入了Y，下一步会让你输入想要保存的文件名。如果不需要修改文件名直接回车就行；若想要保存成别的名字（也就是另存为）则输入新名称然后确 定。这个时候也可用Ctrl+C来取消返回。</li></ul><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a><a href="http://man.linuxde.net/vi" target="_blank" rel="noopener">vi</a></h4><blockquote><p>vi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。Linux中的vi编辑器叫vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。</p></blockquote><p>vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl+u</td><td>向文件首翻半屏； </td></tr><tr><td>Ctrl+d</td><td>向文件尾翻半屏； </td></tr><tr><td>Ctrl+f</td><td>向文件尾翻一屏； </td></tr><tr><td>Ctrl+b</td><td>向文件首翻一屏； </td></tr><tr><td>Esc</td><td>从编辑模式切换到命令模式；</td></tr><tr><td>ZZ</td><td>命令模式下保存当前文件所做的修改后退出vi；</td></tr><tr><td>:行号</td><td>光标跳转到指定行的行首；</td></tr><tr><td>:wq</td><td>在命令模式下，执行存盘退出操作；</td></tr><tr><td>:w</td><td>在命令模式下，执行存盘操作；</td></tr><tr><td>:w!</td><td>在命令模式下，执行强制存盘操作；</td></tr><tr><td>:q</td><td>在命令模式下，执行退出vi操作；</td></tr><tr><td>:q!</td><td>在命令模式下，执行强制退出vi操作；</td></tr><tr><td>:set number</td><td>在命令模式下用于在最左端显示行号；</td></tr><tr><td>:set nonumber</td><td>在命令模式下用于在最左端不显示行号；</td></tr></tbody></table><h3 id="读取文件并输出到-Terminal-窗口"><a href="#读取文件并输出到-Terminal-窗口" class="headerlink" title="读取文件并输出到 Terminal 窗口"></a>读取文件并输出到 Terminal 窗口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat foo.txt                        <span class="comment">#显示文件全部内容</span></span><br><span class="line">cat &gt; filename                     <span class="comment">#创建文件并进入编辑模式</span></span><br><span class="line">cat foo.txt bar.txt &gt; foobar.txt   <span class="comment">#合并文件内容</span></span><br></pre></td></tr></table></figure><h3 id="查看命令的详细帮助"><a href="#查看命令的详细帮助" class="headerlink" title="查看命令的详细帮助"></a>查看命令的详细帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 命令名</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>空格键</td><td>向文件尾部翻一屏</td></tr><tr><td>b</td><td>向文件首部翻一屏</td></tr><tr><td>/</td><td>后跟一个字符串和[Enter]来查找字符串</td></tr><tr><td>n</td><td>发现本次查找的下一个匹配</td></tr><tr><td>N</td><td>发现本次查找的上一个匹配</td></tr><tr><td>q</td><td>退出</td></tr></tbody></table><h3 id="定位某个命令的文件路径"><a href="#定位某个命令的文件路径" class="headerlink" title="定位某个命令的文件路径"></a>定位某个命令的文件路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> 命令</span><br></pre></td></tr></table></figure><p>这个命令会定位某个命令的文件路径。换言之，它会告诉你你执行某个具体命令的时候，在使用哪个文件。</p><h3 id="根据文件的内容输出文件类型"><a href="#根据文件的内容输出文件类型" class="headerlink" title="根据文件的内容输出文件类型"></a>根据文件的内容输出文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 文件路径</span><br></pre></td></tr></table></figure><p>如果一个文件缺失了扩展名，那么这个命令可能会非常有用。</p><h3 id="利用-URL-语法在命令行下工作的文件传输工具"><a href="#利用-URL-语法在命令行下工作的文件传输工具" class="headerlink" title="利用 URL 语法在命令行下工作的文件传输工具"></a>利用 URL 语法在命令行下工作的文件传输工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl www.baidu.com              <span class="comment">#查看网站源码</span></span><br><span class="line">curl -o 文件名 www.sina.com      <span class="comment">#下载</span></span><br></pre></td></tr></table></figure><h3 id="运行脚本命令"><a href="#运行脚本命令" class="headerlink" title="运行脚本命令"></a>运行脚本命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh 脚本文件名</span><br></pre></td></tr></table></figure><p>例: 所有需要的操作存成一个脚本，以后只要运行一次这个脚本就可以了。</p><ol><li>终端中运行nano /clean；</li><li>把下列代码粘贴到 nano 中；<br>rm -rf /System/Library/Extensions.kextcache<br>rm -rf /System/Library/Extensions.mkext<br>chown -R root:wheel /System/Library/Extensions<br>chmod -R 755 /System/Library/Extensions<br>diskutil repairpermissions /<br>kextcache -k /System/Library/Extensions/  </li><li>Ctrl ＋O 存盘，Ctrl＋X 退出；  </li><li>以后只要在终端中运行一次 sh /clean即可；  </li></ol><h3 id="常用解压和压缩命令"><a href="#常用解压和压缩命令" class="headerlink" title="常用解压和压缩命令"></a>常用解压和压缩命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .tar（注：tar是打包，不是压缩）</span></span><br><span class="line">tar xvf FileName.tar             <span class="comment">#解压</span></span><br><span class="line">tar cvf FileName.tar DirName     <span class="comment">#打包</span></span><br><span class="line">tar tvf FileName.tar             <span class="comment">#查看包内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># .zip</span></span><br><span class="line">unzip FileName.zip               <span class="comment">#解压</span></span><br><span class="line">zip FileName.zip DirName         <span class="comment">#打包</span></span><br></pre></td></tr></table></figure><h3 id="say"><a href="#say" class="headerlink" title="say"></a>say</h3><p>say 是一个文本转语音（TTS）的有趣工具，引擎和OS X使用的一样也是VoiceOver。可以用于在脚本中播放警告或提示。例如你可以设置Automator或Hazel脚本处理文件，并在任务完成时用  say 命令语音提示。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 -f 选项朗读特定文本文件，-o 选项将朗读结果存为音频文件而不是播放</span></span><br><span class="line">say -f mynovel.txt -o myaudiobook.aiff</span><br></pre></td></tr></table></figure><h3 id="显示当前日历，或者指定日期的日历"><a href="#显示当前日历，或者指定日期的日历" class="headerlink" title="显示当前日历，或者指定日期的日历"></a>显示当前日历，或者指定日期的日历</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cal      <span class="comment">#输出当前月日历</span></span><br><span class="line">cal 2018 <span class="comment">#输出2018年日历</span></span><br></pre></td></tr></table></figure><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>通过安全的方式使用特殊的权限运行程序（通常为系统的超级用户）<br>默认情况下，任何管理员账户都可以使用sudo来获取 root 权限，甚至当 root 账户在图形界面被禁用的情况下，sudo依然有效。这个命令是很多情况下我们不得不使用 Terminal 的原因，——同样也是给每个用户管理员身份的危险所在。不过，你可以调整sudo的配置文件，来限制它的使用。</p><h2 id="彩蛋时刻"><a href="#彩蛋时刻" class="headerlink" title="彩蛋时刻"></a>彩蛋时刻</h2><ul><li><p>telnet towel.blinkenlights.nl ：星球大战电影  </p></li><li><p>输入emacs，按空格键，再按“esc＋x”键，左下角会出现“M-x”，输入游戏代码，如tetris（俄罗斯方块）、gomoku（五子棋）就能玩玩游戏，open /usr/share/emacs/*/lisp/play 可查看游戏列表。</p></li></ul><blockquote><p>ps: mac自带神的编辑器-Emacs,选择emacs就有来生的，因为一生刚够入门。</p></blockquote><p>参考网址：<br><a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux命令大全</a><br><a href="http://www.cnblogs.com/peida/tag/linux%E5%91%BD%E4%BB%A4/" target="_blank" rel="noopener">每天一个linux命令</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger文档规范</title>
      <link href="/2017/11/01/tool-swagger/"/>
      <url>/2017/11/01/tool-swagger/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a>是一个简单又强大的文档生成工具。在项目中集成这个工具，能够根据配置信息自动为我们生成一个api文档展示页，可以在浏览器中直接访问查看项目中的接口信息，同时也可以测试每个api接口，同时也是前后端开发人员联系的重要纽带。一份功能完整、结构清晰、描述合理的API文档能大大提高前后端的合作开发效率。</p><a id="more"></a><p><br></p><h2 id="合格的swagger文档"><a href="#合格的swagger文档" class="headerlink" title="合格的swagger文档"></a>合格的swagger文档</h2><p>在前后端分离的项目中常常会用到swagger，它既是测试工具，又是前后端沟通的桥梁，在项目中发挥着非常重要的作用。在项目初期，前后端一般都会有个磨合的过程，对swagger文档约定是不可少的。<br>那么，在前端眼中，怎么样算一份<strong>合格易懂</strong>的swagger文档。下面三张图为优秀范例：</p><p><img src="/image/swagger-sandard/swagger1.png" alt="优秀范例"><br><img src="/image/swagger-sandard/swagger2.png" alt="优秀范例"><br><img src="/image/swagger-sandard/swagger3.png" alt="优秀范例"></p><p><strong>以下是我们前端人员常关注的地方：</strong></p><ol><li>一般对应的是 注解中的 @ApiOperation，用在方法上，说明方法的作用。<ul><li>合格点：用中文简单描述。</li></ul></li><li>一般对应的是 注解中的 @ApiModelProperty，用于描述一个model的属性。<ul><li>合格点：<ul><li>有枚举类的属性加上枚举类说明，属性多的情况下尽量多加点中文注释。  </li><li>response格式写完整，不能{ “code”: 0, “data”: {} }  了事。</li></ul></li></ul></li><li>一般对应的是 注解中的 @ApiParam 或者 @ApiImplicitParam， 用于对每个参数的描述。<ul><li>合格点：<ul><li>params格式完整。</li><li>参数多的情况下尽量用中文注释。</li></ul></li></ul></li></ol><p><br><br>一般只要<strong>以下三点达成共识</strong>，那么对接的效率就会事半功倍，也不容易引起不愉快的争吵：</p><ul><li>后端写swagger文档时在以上关注点上下点功夫（一般是从代码中提取注释即可自动生成文档，所以对后端代码可读性也是有好处的）；</li><li>有接口字段改动时第一时间通知前端；</li><li>相同意义字段统一定义；</li></ul><p>  <br></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/u014231523/article/details/76522486" target="_blank" rel="noopener">swagger2常用注解说明</a><br><a href="https://www.jianshu.com/p/12f4394462d5" target="_blank" rel="noopener">swagger常用注解说明</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome调试指南</title>
      <link href="/2017/10/12/tool-devTool/"/>
      <url>/2017/10/12/tool-devTool/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>工欲善其事,必先利其器。</strong><br>轻量 便捷 实时</p><blockquote><p>Chrome 开发者工具是一套内置于Google Chrome中的Web开发和调试工具，可用来对网站进行迭代、调试和分析。</p></blockquote><a id="more"></a><h2 id="如何打开？"><a href="#如何打开？" class="headerlink" title="如何打开？"></a>如何打开？</h2><ul><li>在Chrome菜单中选择 更多工具 &gt; 开发者工具</li><li>在页面元素上右键点击，选择 “检查”</li><li>使用 快捷键 Ctrl+Shift+I (Windows) 或 Cmd+Opt+I (Mac)</li></ul><h1 id="设备模式"><a href="#设备模式" class="headerlink" title="设备模式"></a>设备模式</h1><p><strong>构建完全响应式，移动优先的网络体验</strong></p><blockquote><p>点击它可以切换到不同的终端(移动端和pc端)进行开发模式。<br>还可以选择不同的移动终端设备，同时可以选择不同的尺寸比例。<br>chrome浏览器的模拟移动设备和真实的设备相差不大，是非常好的选择。    </p></blockquote><h2 id="HOW-TO-USE？"><a href="#HOW-TO-USE？" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/device1_2.png" alt="image">  </p><p>除了上图标出的功能，右上角可以发现移动端调试的更多功能哦!<br><img src="/image/devTool/device2.png" width="300"></p><ul><li>Show device frame : 显示设备外壳</li><li>Show media queries : 显示媒体查询(对屏幕大小的判断生成响应式布局)</li><li>Show rulers : 显示标尺</li><li>Add device pixel ratio : 调整设备的像素比例</li><li>Add device type : 调整设备类型</li><li>Capture screenshot : 捕捉当前屏幕截图</li><li>Capture full size screenshot : 捕捉完整屏幕截图</li><li>Reset to defaults : 恢复默认</li></ul><h1 id="元素面板"><a href="#元素面板" class="headerlink" title="元素面板"></a>元素面板</h1><p><strong>使用元素面板可以自由的操作DOM和CSS来迭代布局和设计页面</strong></p><blockquote><p>该面板可以用来查看、修改页面上的元素，包括DOM标签以及css样式的查看、修改(ctrl + z 可撤销修改)，还可以展示相关盒模型的图形信息。    </p></blockquote><h2 id="HOW-TO-USE？-1"><a href="#HOW-TO-USE？-1" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/elments.png" alt="image">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">🚩Tips：在 HTML DOM （文档对象模型）中，每个部分都是节点：  </span><br><span class="line">1、文档本身是文档节点  </span><br><span class="line">2、所有 HTML 元素是元素节点  </span><br><span class="line">3、所有 HTML 属性是属性节点  </span><br><span class="line">4、HTML 元素内的文本是文本节点（包括回车符也是属于文本节点）  </span><br><span class="line">5、注释是注释节点  </span><br><span class="line">Element 对象可以拥有类型为元素节点、文本节点、注释节点的子节点；  </span><br><span class="line">元素也可以拥有属性，属性是属性节点。  </span><br><span class="line">✔️总结：元素是元素节点，是节点中的一种，但元素节点中可以包含很多的节点。</span><br></pre></td></tr></table></figure><p><img src="/image/devTool/elements1.png" alt="image"></p><p>点击箭头按钮可选择元素,激活后，Elements窗口会根据在页面中鼠标的位置自动移动到相应的代码段并显示相关信息。  </p><h3 id="区域①：Html的DOM树结构，可以进行查看定位编辑；"><a href="#区域①：Html的DOM树结构，可以进行查看定位编辑；" class="headerlink" title="区域①：Html的DOM树结构，可以进行查看定位编辑；"></a>区域①：Html的DOM树结构，可以进行查看定位编辑；</h3><ul><li>页面自动标出鼠标悬浮所在代码片段元素</li><li>点击DOM树视图里面的节点，区域2显示相关信息</li><li>直接在某个节点上双击即可修改，且能实时在浏览器里面得到反馈。</li><li>拖拽节点可以直接调整顺序，也可以拖拽节点到编辑器</li><li>浏览器对例如Video、Password等组件进行了封装，无法查看到组件的详细代码，不利于调试。Settings → Preferences → Elements → 勾选Show user agent shadow DOM,这样能够在元素标签器中显示被隐藏的组件代码<h3 id="区域②：编辑修改并实时显示当前选中元素的CSS样式、属性等。"><a href="#区域②：编辑修改并实时显示当前选中元素的CSS样式、属性等。" class="headerlink" title="区域②：编辑修改并实时显示当前选中元素的CSS样式、属性等。"></a>区域②：编辑修改并实时显示当前选中元素的CSS样式、属性等。</h3></li><li>Styles标签页: 显示用户定义的样式，还有开发者工具添加的样式；<ul><li>顶部”Filter”输入框 : 快速查找样式</li><li>顶部”:hov”按钮 : 可强制改变元素状态,:active(当元素被鼠标按下还没有松开，处于激活状态时所显示的状态),:hover(鼠标悬停时显示的状态),:focus(元素获得光标焦点时的状态),:visited(元素被点击后显示的状态)</li><li>顶部”.cls”按钮 : 快速修改元素class</li><li>顶部”+”按钮 : 快速添加class</li><li>单击即可修改样式</li><li>在每个属性后面单击可以添加新的样式</li><li>灰色的element.style同样可以进行添加和书写，唯一区别是在这里添加的样式是添加到了该元素内部，即style属性</li><li>点击样式区域颜色前面的小方块可调出自定义调色板,支持在rgba、hsl和hexadecimal来回切换颜色模式和实时编辑预览页面颜色。</li><li>每行右下角的”┇”可以快速添加阴影、字体颜色、背景颜色</li></ul></li><li>Computed标签页: 显示开发者工具计算好的元素样式（盒式模型）；<ul><li>双击数字即可修改</li></ul></li><li>Event Listeners标签页: 显示当前DOM节点和其祖先节点的所有JavaScript事件监听器,即查看元素上绑定了哪些事件；<ul><li>勾选Ancestors可显示其祖先节点的事件监听器</li><li>勾选Framework listeners:解析框架绑定的事件监听器</li><li>每个事件会有对应的几个属性 handler,useCapture等<ul><li>handler是处理函数, 右键可以看到这个函数定义的位置</li><li>useCapture 是 addEventListener 的第三个参数，如果是true，表示在事件捕获阶段调用事件处理程序；如果是false，表示在事件冒泡阶段调用事件处理程序。</li></ul></li></ul></li><li>DOM Breakpoints标签页: 列出所有的DOM断点；<ul><li>在区域①右键可设置断点</li></ul></li><li>Properties标签页: 全面地列出当前选中元素的属性；</li></ul><h3 id="dom对象的辅助功能"><a href="#dom对象的辅助功能" class="headerlink" title="dom对象的辅助功能"></a>dom对象的辅助功能</h3><p><img src="/image/devTool/elements2.png" width="300"></p><ul><li>Add attribute : 添加元素属性</li><li>Edit attribute : 编辑元素属性</li><li>Edit as HTML : 直接对元素的HTML进行编辑，所有的修改都会即时在页面上得到呈现</li><li>Copy : 复制HTML代码<ul><li>Copy outerHTML : 复制元素内所有的html和文本内容</li><li>Copy selector : 复制元素结构</li><li>Copy xpath : 复制元素路径(爬虫神器)</li><li>Cut element : 剪切元素</li><li>Copy element : 复制元素</li><li>Paste element : 粘贴元素</li></ul></li><li>Hide element : 隐藏元素</li><li>Delete element : 删除元素</li><li>Expand all : 展开元素所有代码</li><li>Collapse all : 折叠元素所有代码</li><li>Scroll into view : 滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素。</li><li>Break on : 可以对某个元素进行监听，在JS对元素的属性或者HTML进行修改的时候，直接触发断点，跳转到对改元素进行修改的JS代码处<ul><li>subtree modifications : 当添加／改变／删除子元素时触发</li><li>attribute modifications : 当元素属性被改变时触发</li><li>node removal : 当移除元素时触发</li></ul></li></ul><h1 id="控制台面板"><a href="#控制台面板" class="headerlink" title="控制台面板"></a>控制台面板</h1><p><strong>在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为shell在页面上与JavaScript交互</strong></p><blockquote><p>console 中有很多对我们调试代码有帮助的函数，我们可以在开发环境中配合 console 来调试代码，使得我们测试更加便利。<br>注： 当需要换到下一行而不是回车的时候，请按Shift+Enter。</p></blockquote><h2 id="HOW-TO-USE？-2"><a href="#HOW-TO-USE？-2" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/console.png" alt="image">  </p><table><thead><tr><th>代码实例</th><th>用途</th></tr></thead><tbody><tr><td>console.log(“这是平凡的字符串”);</td><td>打印字符串</td></tr><tr><td>console.info(“这是温柔的提示”);</td><td>打印提示消息</td></tr><tr><td>console.warn(“这是严肃的警告”);</td><td>打印警告消息</td></tr><tr><td>console.error(“这是错误消息”);</td><td>打印错误消息</td></tr><tr><td>console.debug(“这是调试信息”);</td><td>打印调试信息,console.log方法的别称</td></tr><tr><td>console.log(console);</td><td>打印对象</td></tr><tr><td>console.assert(1 == 0);</td><td>判断真假情况</td></tr><tr><td>console.group(‘报数’);  console.log(“一！”);  console.log(“二！”);  console.groupEnd();</td><td>分组输出</td></tr><tr><td>console.groupCollapsed();</td><td>创建一个新的分组.随后输出到控制台上的内容都会被添加一个缩进,表示该内容属于当前分组,直到调用console.groupEnd() 之后,当前分组结束。</td></tr><tr><td>var data = [{‘姓名’: ‘zlt’, ‘数量’: 1}];    console.table(data);</td><td>显示关联数组信息</td></tr><tr><td>console.dir(document.body);</td><td>将一个 JavaScript 对象的所有属性和属性值显示成一个可交互的列表,以树的结构进行输出</td></tr><tr><td>var test = document.getElementById(‘test’);   console.dirxml(test);</td><td>查看页面中对应元素的 html/xml 内容</td></tr><tr><td>console.log(‘%cMy name is zlt.’, ‘color: #fff; background: #000; font-size: 24px;’);</td><td>特殊的标示符%c，对输出的文字可以附加特殊的样式,background属性的url()中添加图片路径就可以实现图片的输出了 </td></tr><tr><td>$(‘table’)</td><td>返回与指定的CSS选择器相匹配的第一个元素，等同于document.querySelector();如果你使用的库，如jQuery使用$，那么这个功能将被覆盖，并且$将对应用该库的实现</td></tr><tr><td>$$(‘table’)</td><td>返回与指定的CSS选择器相匹配的所有元素的数组，等同于document.querySelectorAll()</td></tr><tr><td>$_</td><td>引用最近的一个表达式,功能与按向上的方向键再回车一样</td></tr><tr><td>$0 ~ $4</td><td>最近选择过的5个DOM节点。$0会返回最近一次点选的DOM结点。以此类推，$1返回的是上上次点选的DOM节点。最多可以保存5个，如果不满5个，则返回undefined。</td></tr><tr><td>$x(‘//*[@id=”console”]/div[2]/table[2]/tbody/tr[4]’)</td><td>返回与指定的XPath相匹配的所有元素的数组</td></tr><tr><td>var data = {name: ‘zlt’,num: 1};   keys(data);</td><td>返回传入对象所有属性名组成的数据</td></tr><tr><td>var data = {name: ‘zlt’,num: 1};   values(data);</td><td>返回所有属性值组成的数组</td></tr><tr><td>inspect(document.body)</td><td>Elements面板跳到需要查看的对象上  </td></tr><tr><td>getEventListeners(document.getElementById  (“eventListeners”)).click[0].listener</td><td>查看某个DOM对象上的事件  </td></tr><tr><td>monitorEvents(document.body, “click”)</td><td>监控相关的事件,unmonitorEvents便是用来停止这一监控</td></tr><tr><td>console.clear()</td><td>清理函数</td></tr><tr><td>clear()</td><td>用 chrome 的 command line api 来清理控制台</td></tr><tr><td>copy(document.body)</td><td>在控制台获取到的内容复制到剪贴板</td></tr><tr><td>document.designMode = “on”</td><td>直接修改网页内容</td></tr></tbody></table><p><strong>monitor(function) 接收一个函数名作为参数，比如function a,每次a被执行了，都会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。 而unmonitor(function)便是用来停止这一监听。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hello,'</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">monitor(sayHello);</span><br><span class="line">sayHello(<span class="string">'zlt'</span>);</span><br><span class="line">unmonitor(sayHello);</span><br><span class="line">sayHello(<span class="string">'zlttt'</span>);</span><br></pre></td></tr></table></figure></p><p><strong>调试一个方法，当该方法调用时会暂停并且在源码中定位，效果和断点类似。undebug可以停止调试。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello,'</span> + name); </span><br><span class="line">&#125;</span><br><span class="line">debug(sayHello);</span><br><span class="line">sayHello(<span class="string">'zlt'</span>);</span><br></pre></td></tr></table></figure></p><p><strong>记录次数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count(name);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hi "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    hi(<span class="string">"person"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hi(<span class="string">"zlt"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>记录代码运行所花费的时间,评估某段代码或是某个函数的性能</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"神机妙算"</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> sum = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> flog = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          flog+=i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"神机妙算"</span>);</span><br></pre></td></tr></table></figure></p><p><strong>评估某段代码或是某个函数的性能,结果显示在 Memory面板的profile中</strong><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.profile(<span class="string">"更高级的神机妙算"</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> sum = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> flog = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          flog+=i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.profileEnd(<span class="string">"更高级的神机妙算"</span>);</span><br></pre></td></tr></table></figure></p><p><strong>追踪函数的调用过程</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> &lt; num) &#123;</span><br><span class="line">    <span class="built_in">console</span>.trace(<span class="string">"现在num的值为"</span>, num);</span><br><span class="line">    <span class="keyword">return</span> num + add(num - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">3</span>;</span><br><span class="line">add(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><h1 id="源代码面板"><a href="#源代码面板" class="headerlink" title="源代码面板"></a>源代码面板</h1><blockquote><p>在源代码面板中设置断点来调试 JavaScript ，或者通过Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器。</p></blockquote><h2 id="HOW-TO-USE？-3"><a href="#HOW-TO-USE？-3" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/sources.png" alt="image">  </p><h3 id="区域①：Sources-Panel-的左侧分别是-Sources-和-Content-scripts和Snippets"><a href="#区域①：Sources-Panel-的左侧分别是-Sources-和-Content-scripts和Snippets" class="headerlink" title="区域①：Sources Panel 的左侧分别是 Sources 和 Content scripts和Snippets"></a>区域①：Sources Panel 的左侧分别是 Sources 和 Content scripts和Snippets</h3><ul><li>Sources : 显示加载的JS、CSS、HTML资源列表，点击后会在区域2显示对应的源代码<ul><li>Workspaces是Chrome DevTools的一个强大功能，这使DevTools变成了一个真正的IDE。只需打开Sources选项，然后右击左边面板的任何一个地方，选择Add Folder To Worskpace，或者只是把你的整个工程文件夹拖放入Developer Tool。</li><li>Workspaces会将Sources选项卡中的文件和本地项目中的文件进行匹配，所以你可以直接编辑和保存，而不必复制/粘贴外部改变的文件到编辑器。</li></ul></li><li>Content scripts : 这是 Chrome 的一种扩展程序， 它是按照扩展的ID来组织的，这些文件也是嵌入在页面中的资源，这类文件可以 读写和操作我们的资源，需要调试这些扩展文件，则可以在这个目录下打开相关 文件调试（但是我们的项目一般没有相关的扩展文件）</li><li>Snippets : 点击创建一个新的片段文件，写完后把右键文件Run，再结合控制台查看相关信息</li></ul><h3 id="区域②：显示源码"><a href="#区域②：显示源码" class="headerlink" title="区域②：显示源码"></a>区域②：显示源码</h3><ul><li>如果当前代码是经过压缩的话，可以点击左下方的花括号{}来增强可读性</li><li>点击JS代码块前面的数字可以设置断点，所有的断点都会列出右侧的断点区；</li><li>除了常规断点外, 还有个条件断点(右键 conditional breakpoint), 在设置的条件为 true 时才会断点, 在循环中需要断点时比较有用.</li><li>在当前的代码执行区域，在调试中如果发现需要修改的地方，可以立即修改，修改后保存即可生效</li></ul><h3 id="区域③：调试的功能区域"><a href="#区域③：调试的功能区域" class="headerlink" title="区域③：调试的功能区域"></a>区域③：调试的功能区域</h3><ul><li>最上面一排按钮分别是：<ul><li>暂停(F8快捷键):继续执行脚本的命令,如果后面还有断点,直接执行到后面的断点,没有断点直接执行到代码最后面</li><li>单步执行(F10快捷键):直接执行完函数进行下一步,不进入函数</li><li>单步跳入此执行块(F11快捷键):进入函数逐步执行函数</li><li>单步跳出此执行块(shift + F11快捷键):跳出函数</li><li>禁用所有断点:注释断点,仍旧显示但是不起作用</li><li>启用所有断点:图标激活之后,在代码出错之后会直接跳转到代码出错的那一行</li></ul></li><li>Watch：可以添加需要监听的变量，执行断点时可以观察变量的变化情况；<ul><li>选中变量后右键add selected text to watches可以添加监听</li><li>Watch窗口可直接添加需要监听的变量</li></ul></li><li>Call Stack：查看断点执行的堆栈情况，可以快速定位断点执行入口；<ul><li>若想重新从某个调用方法处执行，可以右键Restart Frame， 断点就会跳到此处开头重新执行，Scope 中的变量值也会依据代码重新更改</li></ul></li><li>Scope : 查看此时局部变量和全局变量的值</li><li>Breakpoints: 所有当前js的断点都会展示在这个区域，你可以点击按钮用来“去掉/加上”此处断点，也可以点击下方的代码表达式，跳到相应的程序代码处来查看</li><li>XHR Breakpoints: 点击右侧的+号，可以添加请求的URL，一旦 XHR 调用触发时就会在 request.send() 的地方中断</li><li>DOM Breakpoints: 监听和查看某个元素的变化的DOM断点列表</li><li>Event Listener Breakpoints：勾选你要监听的事件，在指定的事件执行时，断点就会有触发；</li></ul><h1 id="网络面板"><a href="#网络面板" class="headerlink" title="网络面板"></a>网络面板</h1><p><strong>使用网络面板了解请求和下载的资源文件并优化网页加载性能</strong></p><blockquote><p>可以看到所有的资源请求，包括网络请求，图片资源，html,css，js文件等请求，可以根据需求筛选请求项，一般多用于网络请求的查看和分析，分析后端接口是否正确传输，获取的数据是否准确，请求头，请求参数的查看。</p></blockquote><h2 id="HOW-TO-USE？-4"><a href="#HOW-TO-USE？-4" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/network.png" alt="image">  </p><h3 id="区域①：Controls工具栏"><a href="#区域①：Controls工具栏" class="headerlink" title="区域①：Controls工具栏"></a>区域①：Controls工具栏</h3><p>用来控制Network的功能及外观,从左往右功能依次为：</p><ul><li>(红色圆点)Record Network Log: 红色表示此时正在记录资源请求信息；</li><li>(灰色🚫)Clear: 清空所有的资源请求信息；</li><li>(摄像标志)捕获快照：选中某一个快照，在概览/请求列表出现的黄色竖线，就是该快照被捕捉的真实时间，双击快照可以放大。</li><li>(过滤标志)Filter: 过滤资源请求信息，选择后，会出现区域2所显示的过滤条件；</li><li>Perserve Log: 勾选后，再次记录请求的信息时不擦除之前的资源信息；</li><li>Disable cache: 勾选后，不允许缓存，所有资源均重新加载</li><li>offline: 勾选后，模拟断开网络</li><li>Online: 选择模拟网络状态</li></ul><h3 id="区域②：Filters筛选栏"><a href="#区域②：Filters筛选栏" class="headerlink" title="区域②：Filters筛选栏"></a>区域②：Filters筛选栏</h3><p>根据筛选条件筛选请求列表，按住command/ctrl键可多选;筛选框可以实现很多定制化的筛选，比如字符串匹配，关键词筛选等，其中关键词筛选主要有如下几种：</p><ul><li>domain：筛选出指定域名的请求，不仅支持自动补全，还支持*匹配。</li><li>has-response-header：筛选出包含指定响应头的请求。</li><li>is：通过is:running找出WebSocket请求。</li><li>larger-than：筛选出请求大于指定字节大小的请求，其中1000表示1k。</li><li>method：筛选出指定HTTP方法的请求，比如GET请求、POST请求等。</li><li>mime-type：筛选出指定文件类型的请求。</li><li>mixed-content：筛选出混合内容的请求（不懂啥意思）。</li><li>scheme：筛选出指定协议的请求，比如scheme:http、scheme:https。</li><li>set-cookie-domain：筛选出指定cookie域名属性的包含Set-Cookie的请求。</li><li>set-cookie-name：筛选出指定cookie名称属性的包含Set-Cookie的请求。</li><li>set-cookie-value：筛选出指定cookie值属性的包含Set-Cookie的请求。</li><li>status-code：筛选出指定HTTP状态码的请求。</li></ul><h3 id="区域③：Overviews-概览"><a href="#区域③：Overviews-概览" class="headerlink" title="区域③：Overviews 概览"></a>区域③：Overviews 概览</h3><p>资源被加载过来的时间线</p><ul><li>如果多条时间线垂直堆叠，表示多个资源被并行加载。</li></ul><h3 id="区域④：Request-Table-请求列表"><a href="#区域④：Request-Table-请求列表" class="headerlink" title="区域④：Request Table 请求列表"></a>区域④：Request Table 请求列表</h3><ul><li>该视窗列出了所有的资源请求，默认按时间顺序排序，点击某个资源，可以查看更详细的信息。</li><li>Name: 资源名称以及URL路径；</li><li>Status: HTTP状态码；</li><li>Type: 请求资源的MIME类型；</li><li>Initiator解释请求是怎么发起的，有四种可能的值：<ul><li>Parser：请求是由页面的HTML解析时发送的;</li><li>Redirect：请求是由页面重定向发送的;</li><li>Script：请求是由script脚本处理发送的;</li><li>Other：请求是由其他过程发送的，比如页面里的link链接点击。</li></ul></li><li>Size: Size是响应头部和响应体结合起来的大小；</li><li>Time: Time是从请求开始到接收到最后一个字节的总时长,可利用区域3进行过滤；</li><li>Waterfall: 显示网络请求的可视化瀑布流，鼠标悬停在某一个时间线上，可以显示整个请求各部分花费的时间</li><li>右键配置可请求列表</li><li>按时shift键，鼠标hover在请求上，可以查看请求的上游和下游，例如hover在common.js上，可以看到有一个绿色请求、一个红色请求。其中绿色请求表示common.js的上游请求，即谁触发了common.js请求，红色请求表示common.js的下游请求，即common.js又触发了什么请求。</li></ul><h3 id="区域⑤：Summary-总览"><a href="#区域⑤：Summary-总览" class="headerlink" title="区域⑤：Summary 总览"></a>区域⑤：Summary 总览</h3><p>汇总了请求数量，传输数据大小，加载时间等信息,从左往右依次显示为：</p><ul><li>X requests:请求总个数</li><li>X transferred:所有请求的大小</li><li>Finish:加载完毕时间</li><li>DOMContentLoaded:页面文档完全加载并解析完毕之后，会触发DOMContentLoaded事件，它在两个地方都有体现：概览视窗的蓝色竖线，总览视窗的触发时间。</li><li>Load:当所有资源加载完成后触发的，它在三个地方有体现：概览视窗的红色竖线，请求列表视窗的红色竖线，总览视窗的触发时间。</li></ul><p><img src="/image/devTool/network2.png" alt="image"><br>点击左侧某一个具体请求URL，可以看到该请求的详细HTTP请求情况：</p><ul><li>Headers：请求头信息和响应头信息</li><li>Preview：预览结果，如果是文件可以查看这个文件；如果是图片可以预览这个图片；如果是从服务器返回来的JSON数据，可以查看格式话后的JSON</li><li>Response：从服务器返回的响应结果</li><li>Cookies：请求和响应的Cookie<ul><li>Name：cookie的名称。</li><li>Value：cookie的值。</li><li>Domain：cookie所属域名。</li><li>Path：cookie所属URL。</li><li>Expire/Max-Age：cookie的存活时间。</li><li>Size：cookie的字节大小。</li><li>HTTP：表示cookie只能被浏览器设置，而且JS不能修改。</li><li>Secure：表示cookie只能在安全连接上传输。</li></ul></li><li>Timing：查看资源请求的生命周期，包含Queing/Stalled/Request/Response/Request sent/Waiting/Content Download各个阶段</li></ul><h1 id="性能面板"><a href="#性能面板" class="headerlink" title="性能面板"></a>性能面板</h1><p><strong>使用性能面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能</strong></p><blockquote><p>在 Chrome 57 之后时间线(Timeline)面板更名为性能(Performance)面板。</p></blockquote><h2 id="HOW-TO-USE？-5"><a href="#HOW-TO-USE？-5" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/performance2.png" alt="image"><br>使用 Chrome DevTools 的 Performance 面板记录程序运行时的所有行为，并用于加以分析是解决程序性能问题的最好方案。 由以下四个子面板构成：</p><ul><li>控制面板（Controls）: 开启记录，停止记录，配置记录期间需要记录的内容。</li><li>概括（Overview）: 对页面表现（行为）的一个概述。<ul><li>概括区域由三个图形记录组成:<ul><li>FPS（Frames Per Second）:绿色的柱越高， FPS 值也越高。FPS 图表上方的红色小块指明了长帧(long frame)，这些可能是卡顿</li><li>CPU(CPU Resources):这个面积图(area chart)表明了哪种事件在消耗 CPU 资源。</li><li>NET:每种不同颜色的条代表一种资源。<ul><li>条越长表明获取该资源所花的时间越长。</li><li>每个条中的浅色部分代表等待时间（资源请求被发送到收到第一个响应字节的时间），深色部分代表文件传输时间（从收到第一个字节到这个资源完全被下载好）</li><li>蓝色 代表 HTML 文件，黄色 代表 Script 文件，紫色 代表 Stylesheets 文件， 绿色 代表 Media 文件，灰色 代表其他资源。</li></ul></li></ul></li></ul></li><li>火焰图（Flame Chart）: 可视化 CPU 堆栈(stack)信息记录。<ul><li>从不同的角度分析框选区域 。例如：Network，Frames, Interactions, Main等</li><li>在 Flame Chart 面板上你可能看到三根垂直的线，蓝线代表 DOMContentLoaded 事件，绿线代表渲染开始的时间( time to first paint)，红线代表 load 事件。</li></ul></li><li>详细信息（Detail）: 当有具体事件被选择时，该面板展示这个事件的更多详细信息。如果没有事件被选择，该面板展示当前所选时间段的一些信息。<ul><li>精确到毫秒级的分析，以及按调用层级，事件分类的整理<ul><li>Summary面板:从宏观层面概括了浏览器加载的总时间<ul><li>颜色：蓝色    ；英文： Loading；含义：加载</li><li>颜色：黄色    ；英文： Scripting；含义：    脚本</li><li>颜色：紫色    ；英文： Rendering；含义：    渲染</li><li>颜色：绿色    ；英文： Painting；含义：    绘制</li><li>颜色：深灰    ；英文： Other；含义：    其他</li><li>颜色：浅灰    ；英文： Idle；含义：    空闲</li></ul></li><li>Bottom-Up面板：The Heavy (Bottom Up) view is available in the Bottom-Up tab<ul><li>Self Time代表函数本身执行消耗时间，Total Time则是函数本身消耗再加上在调用它的函数中消耗的总时间，Activity是浏览器活动。</li><li>Group面板可以很清晰明了得分析按照活动、目录、域、子域、URL和Frame进行分组的前端性能。</li></ul></li><li>Call Tree面板：the Tree (Top Down) view is available in the Call Tree tab<ul><li>Bottom-Up类似事件冒泡，Call Tree类似事件捕获。自上而下的Call-Tree更符合我们的人类正常思维，可以更直观地分析浏览器对页面的build精确到毫秒级的情况</li></ul></li><li>Event Log面板 :展示所有阶段包括loading、javascripting、rendering、painting中各事件的耗时情况，并提供了filter输入框和按钮供你快速过滤。</li></ul></li></ul></li></ul><h1 id="内存面板"><a href="#内存面板" class="headerlink" title="内存面板"></a>内存面板</h1><p><strong>如果需要比性能面板提供的更多信息，可以使用内存面板，例如跟踪内存泄漏</strong></p><blockquote><p>在 Chrome 57 之后分析（Profiles）面板更名为内存（Memory）面板。</p></blockquote><h2 id="HOW-TO-USE？-6"><a href="#HOW-TO-USE？-6" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/memory.png" alt="image"><br>如果在页面中出现卡顿现象，可以使用 CPU 分析器，它准确地记录调用了哪些函数和每个函数花费的时间，</p><ul><li>Take Heap Snapshot:创建堆快照用来显示网页上的JS对象和相关的DOM节点的内存分布情况。<ul><li>利用该工具你可以创建JS的堆快照、内存分析图、对比堆快照以及定位内存泄漏问题。</li><li>选中Take Heap Snapshot,点击Take Snapshot按钮即可获取快照，在每一次获取快照前都会自动执行垃圾回收操作。</li><li>堆快照提供了不同的视角来进行查看：<ul><li>Summary : 该视图按照构造函数进行分组，用它可以捕获对象和它们使用的内存情况，对于跟踪定位DOM节点的内存泄漏特别有用。</li><li>Comparison : 对比两个快照的差别，用它可以对比某个操作前后的内存快照。分析操作前后的内存释放情况以及它的引用计数，便于你确认内存是否存在泄漏以及造成的原因。</li><li>Containment : 该视图可以探测堆的具体内容，它提供了一个更适合的视图来查看对象结构，有助于分析对象的引用情况，使用它可以分析闭包和进行更深层次的对象分析。</li><li>Statistics : 统计视图。</li></ul></li></ul></li><li>Record Allocation Profile:从JS函数角度记录内存的分配信息。<ul><li>点击Start按钮，执行你想要去深入分析的页面操作，当你完成你的操作后点击Stop按钮。然后会显示一个按JS函数进行内存分配的分解图.</li></ul></li><li>Record Allocation Timeline 从整个Heap角度记录内存的分配信息的时间轴信息，利用这个可以实现隔离内存泄漏问题。<ul><li>选中Record Allocation Timeline按钮，点击Start按钮之后，执行你认为可能会引起内存泄漏的操作，操作之后点击左上角的停止按钮即可。</li><li>你可以在蓝色竖线上通过缩放来过滤构造器窗格来仅仅显示在指定的时间帧内的被分配的对象。</li><li>录制过程中，在时间线上会出现一些蓝色竖条，这些蓝色竖条代表一个新的内存分配，这个新的内存分配都可以会有潜在的内存泄露问题。</li><li>通过展开对象并点击它的值则可以在Object窗格中查看更多新分配的对象细节。</li></ul></li></ul><h1 id="应用面板"><a href="#应用面板" class="headerlink" title="应用面板"></a>应用面板</h1><p><strong>使用应用面板可以检查加载的所有资源</strong></p><blockquote><p>在 Chrome 52 之后资源(Resources)面板更名为应用(Application)面板. 该面板可以检查和修改IndexedDB与Web SQL数据库，本地和会话存储，cookie，应用程序缓存，图像，字体和样式表。 点击一次按钮即可清除所有存储、数据库、缓存和服务工作线程。</p></blockquote><h2 id="HOW-TO-USE？-7"><a href="#HOW-TO-USE？-7" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/application.png" alt="image">  </p><ul><li>Local Storage : 如果你在开发过程中使用了local storage来存储键值对(KVPs)，那么你就可以通过Local Storage窗格来检查、新增、修改、删除这个键值对。</li><li>Application Cache : 你可以使用Application Cache窗格去查看通过Application Cache API创建的资源。</li><li>Frames : 将页面上的资源按frame类别进行组织显示。在资源上右击后在弹出菜单选择Reveal in Network Panel，就会跳转到Network面板并定位到该资源的位置。</li></ul><h1 id="安全面板"><a href="#安全面板" class="headerlink" title="安全面板"></a>安全面板</h1><p><strong>使用安全面板调试混合内容问题，证书问题等等。</strong></p><blockquote><p>使用 Security Overview 可以立即查看当前页面是否安全。 检查各个源以查看连接和证书详情（安全源）或找出具体哪些请求未受保护（非安全源）。</p></blockquote><h2 id="HOW-TO-USE？-8"><a href="#HOW-TO-USE？-8" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/security.png" alt="image">  </p><ul><li>如果网页是安全的，则会显示这样一条消息：This page is secure (valid HTTPS)。<ul><li>通过点击View certificate可以查看main origin的服务器证书信息。</li><li>点击左侧可以查看指定源的连接和证书详情。</li></ul></li><li>如果网页是不安全的，则会显示：This page is not secure。该面板可以区分两种类型的不安全的页面：<ul><li>如果被请求的页面通过HTTP提供服务，那么这个主源就会被标记为不安全。</li><li>如果被请求的页面是通过HTTPS获取的，但这个页面接着通过HTTP继续从其他来源检索内容， 那么这个页面仍然被标记为不安全。这就是所谓的混合内容页面,混合内容页面只是部分受到保护, 因为HTTP内容(非加密的内容)可以被嗅探者入侵,容易受到中间人攻击。</li></ul></li></ul><h1 id="检查面板"><a href="#检查面板" class="headerlink" title="检查面板"></a>检查面板</h1><p><strong>对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议</strong></p><blockquote><p>选中Performance, Best Practices, Accessibility, and Progressive Web App，点击Run按钮，将会对当前页面进行网络利用率和页面的性能优化作出诊断，并给出相应的优化建议。 这个对于优化前端页面、加速网页加载速度很有用（相当于Yslow）</p></blockquote><h2 id="HOW-TO-USE？-9"><a href="#HOW-TO-USE？-9" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/audits.png" alt="image"> </p><ul><li>Progressive Web App（在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验）: 检查网页是否符合PWA的标准。</li><li>Performance:检查网页加载时间</li><li>Best Practices : 检查页面是否遵循Google Web开发最佳实践</li><li>Accessibility : 检查网页能否给残障人士使用</li></ul><h1 id="开发者工具主菜单"><a href="#开发者工具主菜单" class="headerlink" title="开发者工具主菜单"></a>开发者工具主菜单</h1><p><strong>自定义并控制DevTools，也叫开发者工具主菜单</strong></p><blockquote><p>单击DevTools窗口右上角的“┇”按钮即可打开主菜单。</p></blockquote><h2 id="HOW-TO-USE？-10"><a href="#HOW-TO-USE？-10" class="headerlink" title="HOW TO USE？"></a>HOW TO USE？</h2><p><img src="/image/devTool/more.png" width="300"></p><ul><li>Dock side: 调整DevTools的位置</li><li>Show console drawer: 打开console的抽屉式选项卡</li><li>Search all files : 在所有文件中搜索</li><li>Open file : 打开指定文件</li><li>More tools: 在抽屉式选项卡中打开更多工具<ul><li>Animations:动画检查器</li><li>Coverage:使用动态分析（Dynamic Analysis）法来收集代码运行时的覆盖率</li><li>JavaScript Profiler:查看JavaScript函数的执行性能</li><li>Layers:看到页面中的复合层。（查找页面原因的时候非常有用）</li><li>Legacy Audits:旧版检查面板,面板的优化建议参照的是雅虎前端工程师的十四条黄金建议。<ul><li>Network Utillzation(网络利用率)、Web Page Performance(界面性能)</li><li>Audit Present State(针对目前网页状态分析)、Reload Page and Audit on load(重新加载网页进行分析)</li></ul></li><li>Network conditions:设置网络节流</li><li>Quick source:打开Source的抽屉式选项卡</li><li>Remote devices:连接远程设备</li><li>Rendering: 渲染设置</li><li>Request blocking:拦截请求</li><li>Search:在所有资源中搜索</li><li>Sensors:仿真面板,模拟移动设备的传感器</li></ul></li><li>Shortcuts:查看快捷键</li><li>Settings:打开设置面板</li></ul><p><img src="/image/devTool/more2.png" alt="image"> </p><ul><li>Preferences :首选项<ul><li>Appearance:外观设置<ul><li>Show third party URL badges:显示第三方URL标记？？？</li><li>Theme:改变devtool主题(简洁白／炫酷黑)</li><li>Panel layout:改变面板布局(横版／竖版／自动)</li><li>Enable Ctrl + 1-9 shortcut to switch panels:用快捷键Ctrl + 1-9来切换面板</li><li>Don’t show Chrome Data Saver warning:不显示chrome的节省数据流量警告</li><li>Disable paused state overlay: 禁用暂停悬浮框状态？？？</li></ul></li><li>Sources:源代码面板设置<ul><li>Automatically reveal files in navigator:在导航栏自动显示文件</li><li>Enable JavaScript source maps:在调试时如果有JS报错，浏览器就会通过解析map文件来重新merge压缩后的JS,使开发者可以用未压缩前的代码来调试。只有Chrome浏览器支持这个功能😲</li><li>Detect indentation:自动检测缩进</li><li>Autocompletion:自动补全</li><li>Bracket matching:括号自动匹配</li><li>Show whitespace characters:空白（空格、TAB、回车）显示设置</li><li>Display variable values inline while debugging:当前调试点及时预览 JavaScript 变量的内联值</li><li>Enable CSS source maps:在调试时如果有CSS报错，浏览器就会通过解析map文件来重新merge压缩后的CSS,使开发者可以用未压缩前的代码来调试。</li><li>Default indentation: 自定义默认缩进</li><li>Search in anonymous and content scripts:在匿名和内容脚本中搜索</li></ul></li><li>Elements:元素面板设置<ul><li>Color format:设置颜色格式</li><li>Show user agent shadow DOM:在元素标签器中显示被隐藏的组件代码</li><li>Word wrap:自动换行</li><li>Show HTML comments:显示HTML注释</li><li>Reveal DOM node on hover:在悬停状态下显示DOM节点</li><li>Show rulers: 鼠标悬停在某个元素上或者选中一个元素的时候会显示</li></ul></li><li>Network:网络面板设置<ul><li>Preserve log:保留请求日志</li><li>Color-code resource types: 不同色彩作标记资源类型</li><li>Group network log by frame:逐帧分组网络日志</li><li>Disable cache (while DevTools is open):禁用缓存</li><li>Enable request blocking:使请求阻塞</li></ul></li><li>Performance:性能面板设置<ul><li>Flamechart mouse wheel action:查看火焰图时鼠标滚轮的作用(缩放/滚动)</li><li>High resolution CPU profiling: 提高记录分析数据的准确性，能够以十分之一毫秒的度量来查看火焰图的数据</li><li>Record heap allocation stack traces:使用 Allocation 视图查看内存分配</li><li>Hide chrome frame in Layers view:Layers视图中隐藏谷歌浏览器内嵌框架(通过Internet Explorer的用户界面，以Chrome内核的渲染方式浏览网页)</li><li>Show native functions in JS Profile:使用 profiler 查看原生函数的执行性能</li></ul></li><li>Console:控制台面板设置<ul><li>Hide network messages:默认情况下，控制台将报告网络问题。启用此设置将指示控制台不显示这些错误的日志。例如，将不会记录 404 和 500 系列错误。</li><li>Selected context only:仅显示当前上下文的信息(top iframe worker extension)</li><li>User messages only: 仅显示console API方法的信息</li><li>Log XMLHttpRequests:确定控制台是否记录每一个 XMLHttpRequest。</li><li>Show timestamps:在调用时向显示的每条控制台消息追加一个时间戳。对于发生特定事件时的调试非常实用。这会停用消息堆叠。</li><li>Autocomplete from history:历史记录提示</li><li>Enable custom formatters:控制 JavaScript 对象的格式设置。</li><li>Preserve log upon navigation:在页面刷新或导航时保留控制台历史记录。</li></ul></li><li>Extensions:扩展<ul><li>Link handling:链接处理</li></ul></li><li>Debugger:断点设置<ul><li>Disable JavaScript:禁用JavaScript</li><li>Disable async stack traces:禁用异步堆栈跟踪</li></ul></li><li>DevTools<ul><li>Auto-open DevTools for popups:当新的标签/新窗口打开时,自动打开浏览器开发工具</li></ul></li></ul></li><li>Workspace :把本地服务器的资源映射为硬盘上的文件，实现调试 JS 和 CSS 的同时自动保存文件</li><li>Blackbox:屏蔽JS文件<ul><li>库代码（被屏蔽的文件）里抛出异常时不会暂停（当设置为Pause on exceptions时）</li><li>调试时Stepping into/out/over都会忽略库代码</li><li>事件断点也会忽略库代码</li><li>库代码里设置的任何断点也不会起作用</li><li>最终的结果就是只会调试应用代码而忽略第三方代码（配置了Blackbox的代码）。</li></ul></li><li>Emulated Devices:管理模拟设备</li><li>Throttling:设置网络延迟与带宽</li><li>Shortcuts:查看快捷键</li></ul><h3 id="最后还有！"><a href="#最后还有！" class="headerlink" title="最后还有！"></a>最后还有！</h3><p><strong>小技能</strong></p><ul><li>在浏览器地址栏输入：chrome://about/,你看到得这些地址几乎包含了所有谷歌浏览器的实用功能，下面来详解部分常用功能。</li><li>清除缓存、硬重载:如果你请求一个硬刷新，在开发者工具打开的情况下点击并按住 Chromes 的刷新按钮。你应该会看见一个下拉菜单，它允许你进行清除缓存和并进行硬重载。</li><li>任务管理器：在浏览器工具栏中点击 Chrome 菜单，选择更多工具，选择任务管理器。可以让你深入了解任何选项卡对应的 GPU，CPU 以及 JavaScript 内存使用状况，CSS 和脚本缓存使用状况。</li><li><a href="https://plus.google.com/+AddyOsmani/posts/ih85hKCyGve" target="_blank" rel="noopener">JSRunTime</a>：开发者工具检索 JavaScript 对象的拓展,它可以在内存中检索可用的 JavaScript 对象并生成相应的图，还可以根据值或者名称来进行匹配。</li><li><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener">Vue.js devtools</a>：墙裂推荐，调试vue应用的神器</li></ul><blockquote><p>这些只是chrome Devtool的其中一部分功能，还有待补充。目前只能算入门篇。<br>so,欢迎来找我讨论补充～   </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/06/15/tool-hexo/"/>
      <url>/2017/06/15/tool-hexo/</url>
      
        <content type="html"><![CDATA[<div class="note info">博客使用了NEXT主题，特此贴上我的配置代码。<a href="https://hexo.io/docs/" target="_blank" rel="noopener">More info</a></div><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#将.deploy目录部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br><span class="line">hexo deploy -g  <span class="comment">#生成加部署</span></span><br><span class="line">hexo server -g  <span class="comment">#生成加预览</span></span><br><span class="line">hexo clean  <span class="comment">#把public静态文件清空再重新生成部署</span></span><br><span class="line">命令的简写</span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br><span class="line">hexo g -d == hexo generate hexo deploy</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="需要修改的文件"><a href="#需要修改的文件" class="headerlink" title="需要修改的文件"></a>需要修改的文件</h2><h3 id="themes-next-source-css-common-components-tags-label-styl"><a href="#themes-next-source-css-common-components-tags-label-styl" class="headerlink" title="themes/next/source/css/_common/components/tags/label.styl"></a>themes/next/source/css/_common/components/tags/label.styl</h3><p>注释掉 white-space: nowrap;</p><h3 id="themes-next-source-images"><a href="#themes-next-source-images" class="headerlink" title="themes/next/source/images"></a>themes/next/source/images</h3><p>该目录下创建global目录，放入</p><ul><li><a href="https://zhaoluting.github.io/images/global/background.jpg">background.jpg</a></li><li><a href="https://zhaoluting.github.io/images/global/favicon-16x16-next.png">favicon-16x16-next.png</a></li><li><a href="https://zhaoluting.github.io/images/global/favicon-32x32-next.png">favicon-32x32-next.png</a></li></ul><h3 id="themes-next-source-lib"><a href="#themes-next-source-lib" class="headerlink" title="themes/next/source/lib"></a>themes/next/source/lib</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-fancybox3 <span class="built_in">source</span>/lib/fancybox</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure><h3 id="themes-next-config-yml"><a href="#themes-next-config-yml" class="headerlink" title="themes/next/_config.yml"></a>themes/next/_config.yml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置图标 --&gt;</span></span><br><span class="line">favicon:</span><br><span class="line">  small: /images/global/favicon-16x16-next.png</span><br><span class="line">  medium: /images/global/favicon-32x32-next.png</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置页脚 --&gt;</span></span><br><span class="line">footer:</span><br><span class="line">  since: 2017</span><br><span class="line">  <span class="comment">&lt;!-- 设置页脚动效 --&gt;</span></span><br><span class="line">  icon:</span><br><span class="line">    name: heart</span><br><span class="line">    animated: true</span><br><span class="line">    color: "#a88771"</span><br><span class="line">  <span class="comment">&lt;!-- 隐藏自带版本信息 --&gt;</span></span><br><span class="line">  powered:</span><br><span class="line">    enable: false</span><br><span class="line">    version: false</span><br><span class="line">  theme:</span><br><span class="line">    enable: false</span><br><span class="line">    version: false</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置顶部菜单栏 --&gt;</span></span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  schedule: /schedule/ || calendar</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 右侧展开显示的联系方式 --&gt;</span></span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/zhaoluting || github</span><br><span class="line">  E-Mail: mailto:839327424@qq.com || envelope</span><br><span class="line">  More: https://zhaoluting.github.io/about/ || vcard</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 右侧展开显示的更多信息 --&gt;</span></span><br><span class="line">links_icon: code</span><br><span class="line">links_title: 技术栈</span><br><span class="line">links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  React: https://react.docschina.org/</span><br><span class="line">  TypeScript: https://www.typescriptlang.org/</span><br><span class="line">  Vue: https://cn.vuejs.org/</span><br><span class="line">  mpvue: http://mpvue.com/</span><br><span class="line">  Node: https://nodejs.org/en/</span><br><span class="line">  Pupprteer: https://pptr.dev/</span><br><span class="line">  Webpack: https://webpack.js.org/</span><br><span class="line">  MySQL: https://www.mysql.com/</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置右侧展开头像 --&gt;</span></span><br><span class="line">avatar:</span><br><span class="line">  url: /images/global/favicon-32x32-next.png</span><br><span class="line">  rounded: true</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 页面右下角滚动显示百分比 --&gt;</span></span><br><span class="line">sidebar:</span><br><span class="line">  scrollpercent: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 文章信息显示设置 --&gt;</span></span><br><span class="line">post_meta:</span><br><span class="line">  updated_at:</span><br><span class="line">    <span class="comment">&lt;!-- 不显示修改日期 --&gt;</span></span><br><span class="line">    enabled: false</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 文章字数统计显示 https://github.com/theme-next/hexo-symbols-count-time --&gt;</span></span><br><span class="line">symbols_count_time:</span><br><span class="line">  <span class="comment">&lt;!-- 是否单独成一行  --&gt;</span></span><br><span class="line">  separated_meta: false</span><br><span class="line">  <span class="comment">&lt;!-- 文章中的显示是否显示文字（本文字数|阅读时长）  --&gt;</span></span><br><span class="line">  item_text_post: false</span><br><span class="line">  <span class="comment">&lt;!-- 网页底部的显示是否显示文字（站点总字数|站点阅读时长）  --&gt;</span></span><br><span class="line">  item_text_total: false</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 代码块具备复制功能 --&gt;</span></span><br><span class="line">codeblock:</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 安卓浏览器样式优化 --&gt;</span></span><br><span class="line">android_chrome_color: "#a88773"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 打开本地搜索功能 --&gt;</span></span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 主题自带样式 note 标签配置，详见https://github.com/iissnan/hexo-theme-next/pull/1697 --&gt;</span></span><br><span class="line">note:</span><br><span class="line">  style: simple</span><br><span class="line">  icons: true</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选项卡样式配置，详见https://almostover.ru/2016-01/hexo-theme-next-test/#Tab-tag-test --&gt;</span></span><br><span class="line">tabs:</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启图片预览功能 --&gt;</span></span><br><span class="line">fancybox: true</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 显示顶部阅读进度条 --&gt;</span></span><br><span class="line">pace: true</span><br><span class="line">pace_theme: pace-theme-flash</span><br><span class="line">pace: true</span><br></pre></td></tr></table></figure><h3 id="themes-next-source-css-custom-custom-styl"><a href="#themes-next-source-css-custom-custom-styl" class="headerlink" title="themes/next/source/css/_custom/custom.styl"></a>themes/next/source/css/_custom/custom.styl</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">//首页文章阴影样式</span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">14px</span> <span class="built_in">rgba</span>(202, 203, 203, .5);</span><br><span class="line">    <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">14px</span> <span class="built_in">rgba</span>(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br><span class="line">//热评文章</span><br><span class="line"><span class="selector-class">.ds-top-threads</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">transition</span>: border-width <span class="number">0.2s</span> linear <span class="number">0s</span>, color <span class="number">0.2s</span> linear <span class="number">0s</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ds-top-threads</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">8px</span> solid <span class="number">#4d768c</span>;</span><br><span class="line">&#125;</span><br><span class="line">//首页头部样式</span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"../../images/global/background.jpg"</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#A48777</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.headband</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#926f5a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.brand</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#d08e65cc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ffffff59</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.logo-line-before</span>,</span><br><span class="line"><span class="selector-class">.logo-line-after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-class">.menu-item</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(15, 46, 65);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-meta</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    .site-title &#123;</span><br><span class="line">        <span class="selector-tag">font-size</span>: 35<span class="selector-tag">px</span>;</span><br><span class="line">        font-family: 'Comic Sans MS', sans-serif;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">        <span class="selector-tag">height</span>: 50<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">padding-top</span>: 5<span class="selector-tag">px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//首页尾部样式</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer-inner</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'Comic Sans MS'</span>, sans-serif;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a88772</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#a88773</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">2px</span> <span class="number">6px</span> <span class="number">#724d38</span>;</span><br><span class="line">    .sidebar-inner &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-id">#e6c5b2</span>;</span><br><span class="line">        // 侧栏头像</span><br><span class="line">        <span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">transition</span>: transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">            <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        //侧边栏信息样式修改</span><br><span class="line">        <span class="selector-class">.site-author-name</span> &#123;</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">font-family</span>: <span class="string">'Comic Sans MS'</span>, sans-serif;</span><br><span class="line">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.site-description</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#e6c5b2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">a</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">border-bottom-color</span>: <span class="number">#e6c5b2</span>;</span><br><span class="line">            <span class="attribute">border-bottom</span>: none;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.sidebar-nav</span> &#123;</span><br><span class="line">            .sidebar-nav-active &#123;</span><br><span class="line">                <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">                <span class="selector-tag">border-bottom-color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-tag">li</span> &#123;</span><br><span class="line">                <span class="attribute">color</span>: <span class="number">#e1c6b5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">                <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-class">.sidebar-nav-active</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">                <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.site-state</span> &#123;</span><br><span class="line">            .site-state-item &#123;</span><br><span class="line">                <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line">                <span class="selector-tag">padding</span>: 8<span class="selector-tag">px</span> 28<span class="selector-tag">px</span>;</span><br><span class="line">                <span class="selector-tag">border-left</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#e6c5b2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.links-of-blogroll</span> &#123;</span><br><span class="line">            <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">            <span class="attribute">margin-bottom</span>: <span class="number">42px</span>;</span><br><span class="line">            .links-of-blogroll-title &#123;</span><br><span class="line">                font-family: 'Comic Sans MS', sans-serif;</span><br><span class="line">                <span class="selector-tag">font-size</span>: 16<span class="selector-tag">px</span>;</span><br><span class="line">                <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-class">.links-of-blogroll-list</span> &#123;</span><br><span class="line">                <span class="attribute">border-top</span>: <span class="number">1px</span> dotted;</span><br><span class="line">                <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">                <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">                <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.links-of-author</span> &#123;</span><br><span class="line">            <span class="attribute">margin-bottom</span>: <span class="number">70px</span>;</span><br><span class="line">            .links-of-author-item i &#123;</span><br><span class="line">                <span class="selector-tag">margin-right</span>: 3<span class="selector-tag">px</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //文章目录样式</span><br><span class="line">        <span class="selector-class">.post-toc</span> &#123;</span><br><span class="line">            .nav .active&gt;a &#123;</span><br><span class="line">                <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-tag">ol</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">                <span class="attribute">color</span>: <span class="number">#e0c6b5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-tag">ol</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">                <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧栏按钮样式</span><br><span class="line"><span class="selector-class">.sidebar-toggle</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#a88772</span>;</span><br><span class="line">    .sidebar-toggle-line &#123;</span><br><span class="line">        <span class="selector-tag">background</span>: <span class="selector-id">#ffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-nav-toggle</span> &#123;</span><br><span class="line">    .btn-bar &#123;</span><br><span class="line">        <span class="selector-tag">background</span>: <span class="selector-id">#a88772</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#a88772</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//首页文章块样式</span><br><span class="line"><span class="selector-class">.post-type-normal</span> &#123;</span><br><span class="line">    //首页阅读全文样式</span><br><span class="line">    <span class="selector-class">.post-button</span> &#123;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line">        .btn &#123;</span><br><span class="line">            <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">            <span class="selector-tag">font-size</span>: 15<span class="selector-tag">px</span>;</span><br><span class="line">            <span class="selector-tag">background</span>: <span class="selector-id">#ae866f</span>;</span><br><span class="line">            <span class="selector-tag">border-radius</span>: 16<span class="selector-tag">px</span>;</span><br><span class="line">            <span class="selector-tag">line-height</span>: 2;</span><br><span class="line">            <span class="selector-tag">margin</span>: 0 4<span class="selector-tag">px</span> 8<span class="selector-tag">px</span> 4<span class="selector-tag">px</span>;</span><br><span class="line">            <span class="selector-tag">padding</span>: 0 20<span class="selector-tag">px</span>;</span><br><span class="line">            <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#926f5a</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">a</span>&#123;</span><br><span class="line">            <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#926f5a</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#fff1ea</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.post-footer</span> &#123;</span><br><span class="line">        .post-eof &#123;</span><br><span class="line">            <span class="selector-tag">margin</span>: 20<span class="selector-tag">px</span> <span class="selector-tag">auto</span> 10<span class="selector-tag">px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 代码块复制按钮样式</span><br><span class="line"><span class="selector-class">.highlight-wrap</span> <span class="selector-class">.copy-btn</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#8D908C</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.posts-expand</span> &#123;</span><br><span class="line">    .post-body &#123;</span><br><span class="line">        <span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">            <span class="attribute">transform</span>: initial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">a</span> &#123;</span><br><span class="line">            <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
